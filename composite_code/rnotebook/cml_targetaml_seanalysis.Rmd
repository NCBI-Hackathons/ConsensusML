---
title: "Discovery of Acute Myeloid Leukemia Biomarkers using Ensemble Machine Learning"
author:
- Sean Maden
- Jenny Smith
output: html_notebook

---


#Set-up 

```{r setup, include=FALSE}
require(knitr)
# knitr::opts_knit$set(root.dir = '~/Documents/GitHub/RNAseq_Cancer_Biomarkers/')
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=50),
                      tidy=TRUE, 
                      fig.align='center', 
                      fig.height=5, 
                      fig.width=8, 
                      dpi = 600,
                      echo=FALSE,
                      eval=TRUE)

options(stringsAsFactors = FALSE)
```

```{r libraries, eval=TRUE, echo=FALSE, message=FALSE}
# get dependency libraries

#==========
# install
#==========
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install(c("edgeR","MLSeq","DESeq2"))

#======
# load
#======
library(plyr)
library(mlr)
library(magrittr)
library(ggplot2)
library(glmnet)
library(ROSE)
library(stringr)
library(dplyr)
library(tibble)
library(tidyr)
library(limma)
library(edgeR)
library(MLSeq)
library(DESeq2)
library(MLmetrics)
# library(xlsx) #java image no found??
library(VennDiagram)
library(SummarizedExperiment)
library(GenomicRanges)
library(circlize)
library(reshape2)
library(biomaRt)
# library(EnsDb.Hsapiens.v75)



```

## ML Functions

```{r}
# Lasso
runLasso <- function(seset, seed=2019, type.measure="class"){
  # credit base code: Jenny Smith
  # runLasso
  # Fit a model using penalized regression with lasso
  # Arguments:
  # * sese: Valid summarized experiment object
  # * seed: (int) set seed for randomization
  # Returns:
  # * resultslist (list) : Results of lasso fit
  
  require(glmnet)
  require(SummarizedExperiment)
  set.seed(seed) 

  #define train/test sets 
  train.names = colnames(assay(seset[,seset$exptset.seahack=="train"]))
  test.names = colnames(assay(seset[,seset$exptset.seahack=="test"]))
  
  #define predictors and response variables
  df = t(assay(seset))
  response <- seset$deg.risk
  predictors <- rownames(seset)
  
  y <- factor(response); names(y) <- colnames(assay(seset)) # response var obj
  x = df[,predictors] # genes of interest
  contrast <- contrasts(y)
  
  #lambda values
  grid <- 10^ seq(10,-2, length=100)
  
  #standardize is an option to mean center. 
  #Don't use since we want to keep the natural variation and expression is already normalized for sample to  sample comparisons.
  standardize = FALSE
  
  fit <- glmnet(x[train.names,], y[train.names], family = "binomial", alpha=1, 
                standardize = standardize, lambda = grid, intercept = FALSE)
  
  # use cross-validation on the training model.CV only for lambda
  cv.fit <- cv.glmnet(x[train.names,], y[train.names], family = "binomial",
                      type.logistic="modified.Newton", standardize = standardize,
                      lambda = grid, alpha=1, nfolds = length(train.names), #LOOCV 
                      type.measure = type.measure, intercept = FALSE)
  
  #Select lambda min.
  lambda.min <- cv.fit$lambda.min
  
  #predict the classes
  pred.class <- predict(fit, newx = x[test.names,], type="class", s=lambda.min)
  pred.prob <- predict(fit, newx = x[test.names,], type="response", s=lambda.min)
  
  
  #find the test error
  tab <- table(pred.class,y[test.names])
  testError <- mean(pred.class != y[test.names]) #how many predicted classes were incorrect
  log.loss <- LogLoss(y_pred = pred.prob[,1], y_true = as.numeric(as.character(y[test.names]))) #difference from predicted label to true label
    
  #Fit the full dataset.
  final <- glmnet(x, y,family = "binomial", standardize = standardize, 
                  lambda = grid, alpha = 1, intercept = FALSE)
  
  #Extract the coefficients
  coef <- predict(final, type="coefficients", s=lambda.min)
  idx <- which(!as.numeric(coef)==0)
  nonZero <- coef[idx,]
  
  #Results 
  resultslist <- list("training.set"=train.names, 
                      "testing.set"=test.names, 
                      "contrast"=contrast, 
                      "train.fit"=fit, 
                      "cv.fit"= cv.fit,
                      "pred.probability"=pred.prob,
                      "confusionMatrix"=tab,
                      "test.error"=testError, 
                      "log.loss"=log.loss,
                      "final.model"= final, 
                      "nonzero.coef"=nonZero, 
                      "seed"=seed)

  return(resultslist)
}

#Function for SVM classification. 
runSVM <- function(seed,kerneltype="linear",seset, weightfilt=FALSE){
  # credit base code: Sean Maden
  # run SVM optimization
  # Arguments
  #   * seed : set seed (int) for randomization
  #   * kerneltype : (str) valid kernel type class for SVM (e.g. 'linear', 'radial', etc.)
  #   * seset : summarized expirment object with both test and training set data. 
  #       * ndtr : training dataset (excluding sample classes)
  #       * ndtr.classes : classes for training sampels (vector) with 1:1 correspondence 
  #       with trainset rows
  #       * ndte : test data (data frame or matrix), excluding classes
  #       * ndte.classes : classes for test samples (vector), with 1:1 row:pos correspondence
  #   * weightfilt : (FALSE or numeric float) top fraction weights to use in model 
  #       (if FALSE, then all weights used) 
  # Returns
  #   * rl (list) : list containing model fitted, predictions, and performacne metrics
  require(e1071); require(ROCR); require(MLmetrics)
  rl <- list(); str.options <- ""
  set.seed(seed)
  
  #training/testing sets
  ndtr <- t(assay(seset[,seset$exptset.seahack=="train"]))
  ndtr.classes <- seset[,seset$exptset.seahack=="train"]$deg.risk
  
  ndte <- t(assay(seset[,seset$exptset.seahack=="test"]))
  ndte.classes <- seset[,seset$exptset.seahack=="test"]$deg.risk
  # train svm model
  svm_model <- svm(as.factor(ndtr.classes)~., 
                   data=ndtr, 
                   method="C-classification", 
                   kernel=kerneltype,
                   probability=TRUE)
  weightsvect <- ndtr.weights <- t(svm_model$coefs) %*% svm_model$SV
  if(weightfilt){
    str.options <- c(str.options,paste0("weight filt = ",weightfilt))
    # order training data on relative weights
    ndtr.weightsort <- ndtr[,rev(order(abs(ndtr.weights)))]
    # select only top proportion weights
    nweight.col = round(ncol(ndtr.weightsort)*weightfilt,0)
    ndtr.weightfilt <- ndtr.weightsort[,c(1:nweight.col)]
    str.options <- c(str.options,paste("cols_retained:",colnames(ndtr.weightfilt),collapse=";"))
    # redefine training set, rerun SVM optimization
    ndtr <- ndtr.weightfilt
    svm_model <- svm(as.factor(ndtr.classes)~., 
                     data=ndtr, 
                     method="C-classification", 
                     kernel=kerneltype,
                     probability=TRUE)
  } else{
    str.options <- c(str.options,"no weight filt")
  }
  
  #training and test set predictions.
  pred_train <- predict(svm_model, ndtr, decision.valuesq = TRUE, probability=TRUE)
  pred_test <- predict(svm_model, ndte, decision.values = TRUE, probability=FALSE)
  pred_test2 <- predict(svm_model, ndte, decision.values = TRUE, probability=TRUE)
  #find the test errors
  tab <- table(pred = pred_test, true = ndte.classes)
  testError <- mean(pred_test != ndte.classes) #how many predicted classes were incorrect
  log.loss <- LogLoss(y_pred = attr(pred_test2, which="probabilities")[,1], y_true = as.numeric(ndte.classes))
  # get performance metrics
  pred <- prediction(as.numeric(attr(pred_test,"decision.values")),ndte.classes)
  perf <- performance(pred,"tpr","fpr")
  ppred <- pred_test[pred_test==1] 
  tppred <- ndte.classes[pred_test==1]
  ppred <- as.numeric(as.character(ppred))
  testprec <- length(ppred[ppred==tppred])/length(ppred) # test precision
  rposi <- ndte.classes==1
  rtpred <- ndte.classes[rposi]
  rppred <- pred_test[rposi]
  rppred <- as.numeric(as.character(rppred))
  testrec <- length(rppred[rppred==1])/length(rppred) # test recall
  
  # return model, pred's, and performance metrics
  rl <- list(str.options,
             svm_model,
             weightsvect,
             pred_train,
             pred_test,
             pred_test2,
             perf,
             tppred,
             testprec,
             testrec, 
             tab,
             testError, 
             log.loss)
  names(rl) <- c("options_string",
                 "svm_model",
                 "weightsvect",
                 "predictions_train",
                 "predictions_test",
                 "predictions_test2",
                 "performance_test",
                 "TPR_test",
                 "precision_test",
                 "recall_test", 
                 "confusionMatrix",
                 "testError",
                 "log.loss")
  return(rl)
  
}
```


```{r utilityfunctions, eval=FALSE}
# utilities for data summaries and visualization

#==============================
# differential gene expression
#==============================
voom_DE <- function(counts.df, ref, pheno){
  # credit base code: Jenny Smith
  #counts.df is a dataframe with count data, with genes as rownames
  #pheno is a character vector with patient IDs as names, and the status for each in each group(eg pos,neg)
  require(edgeR)
  library(limma)
  
  #ensure correct order for both expn and counts.df
  samples <- intersect(names(pheno), colnames(counts.df))
  pheno <- pheno[samples]
  counts.df <- counts.df[,samples]
  
  #define phenotype groups (eg control vs treatment)
  groups <- unique(pheno)
  groups <- c(groups[groups != ref], ref) #order so that reference is second 
  pheno.f <- factor(pheno, levels=groups)
  
  #create DGE object 
  dge <- DGEList(counts = counts.df, group = pheno.f)
  
  #filter genes that have greater than 1 CPM in at least 5% of samples
  keep.dge <- rowSums(cpm(dge) >= 1) > (0.05*ncol(counts.df)) 
  dge <- dge[keep.dge,]
  dge <- calcNormFactors(dge) #TMM normalize
  
  #create design matrix for DE contrasts
  design <- model.matrix(~0 + pheno.f, data=dge$samples)
  colnames(design) <- levels(pheno.f)
  cont.matrix <- makeContrasts(contrasts = paste(groups, collapse = "-"), levels = design)
  
  #voom transform
  v.lv <- voom(dge, design, plot = FALSE)
  
  #fit linear model and compute moderated t-statistics using empirical Bayes
  fit <- lmFit(v.lv, design)
  fit <- contrasts.fit(fit, contrasts = cont.matrix)
  fit <- eBayes(fit)
  #extract the differentially expressed genes with abs log2FC >= 1 and FRD < 0.05
  table <- topTable(fit, number = 20000, p.value=0.05, adjust.method="BH", sort.by="P",lfc=1)
  


  list <- list(design, v.lv, fit, table)
  names(list) <- c("desingMatrix", "voomTransformation", "fit", "DEGs")
  return(list)
}

#=================
# Convert Ensmebl IDs to Gene Names
#=================
ensembl_ID_conversion <- function(Ensembl.IDs){

  lib.path <- strsplit(version[['version.string']], ' ')[[1]][3] %>% 
    gsub("\\.[0-9]{1,}$", "", . )  %>% 
    paste0(.libPaths()[1], .) #uses first default lib.path.
  
  library(biomaRt, lib.loc = lib.path)
  
 
  mart <- useEnsembl(biomart = "ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl") 
  attr.mart <-  c("ensembl_gene_id", "external_gene_name","hgnc_symbol")
  
  res <- getBM(attributes = attr.mart,
                    filters = "ensembl_gene_id",
                    values = Ensembl.IDs,
                    mart = mart)
  
  return(res)
}


#=================
# categorize DEGs
#=================
catExpnData <- function(filenames,regex, cols, header=FALSE,removeFirstLine=FALSE, sep="\t"){
  #credit base code: Jenny Smith
  # Purpose: Concatenate the expression data-sets downloaded from TCGA/TARGET from GDC or any patient level data
  #eg. each individual patient has a single expression-file 
  
  library(magrittr)
  options(stringsAsFactors = FALSE)
  #filenames is a character vector of all filenames. 
  #regex is a string with the pattern to extract the patient ID , eg "^.+(Kasumi|MV4)", from filenames 
  #cols is the character vector or numeric vector of the columns to select and concatenate. 
  
  #function to read in a file and split it into a list of individual columns 
  extract_cols <-function(filename,cols,rmFirstLine=FALSE){
    
    if(all(rmFirstLine & header)){
      aFile <- readLines(filename)[-1] #remove first line with extra info. 
      aFile <- str_split_fixed(aFile, pattern = "\t",n = length(cols)) %>% #split into a matrix
        set_colnames(.[1,] ) %>%  #set colnames from the first line 
        .[-1, ] #remove the header row from matrix
    }else{
      aFile <- read.delim(filename, sep=sep, header=header, as.is=TRUE)
    }
    
    output <- list()
    for ( k in 1:length(cols)){
      colname <- cols[k]
      col <- aFile[,colname]
      output[[colname]] <- col
    }
    return(output)
  }
  
  #function to combine the elements of the list of columns into a matrix.
  combineColumns <- function(extract_cols.res,colname){
    sapply(extract_cols.res, '[[', colname)
  }
  
  #define the IDs for the columns
  IDs <- gsub(regex, "\\1", filenames)
  
  columns <- lapply(filenames,extract_cols,cols=cols, rmFirstLine=removeFirstLine) %>%
    set_names(IDs)
  
  catedMatrices <- lapply(cols, combineColumns, extract_cols.res=columns)  %>%
    set_names(cols)
  
  
  return(catedMatrices)
}

#==============
# volcano plot
#==============
volcano_plot <- function(fit, cut.off=4, label.offset=0.5){
  require(ggrepel)
  # credit base code: Jenny Smith
  #fit is the eBayes fit from limma. 
  
  df <- data.frame(logFC=fit$coefficients[,1],
                   pValue=fit$p.value[,1],
                   FDR=p.adjust(fit$p.value[,1], method="BH"),
                   MeanExpression=fit$Amean) %>%
      rownames_to_column("Gene") %>%
      mutate(Neg.Log10.P= -log10(pValue),
             DEGs.Groups=case_when(
                  logFC > 1.0 & pValue < 0.05 ~ "FC Greater than 2",
                  logFC < -1.0 & pValue < 0.05 ~ "FC Less than 2",
                  TRUE ~ "Not Significant FC"))

  
  #Select differentially expressed genes to highlight in the plot. 
  ToHighlight <- df[abs(df$logFC) > cut.off & df$FDR < 0.05, "Gene"] 
  idx <- which(abs(df$logFC) > cut.off & df$FDR < 0.05)
  
  vplot <- ggplot(df, aes(x=logFC, y=Neg.Log10.P)) + 
    geom_point(data = filter(df, DEGs.Groups == "Not Significant FC"), 
               mapping = aes(x=logFC, y=Neg.Log10.P, color=DEGs.Groups), alpha=0.65)  +
    
    geom_point(data= filter(df, grepl("2", DEGs.Groups)), 
               mapping = aes(x=logFC, y=Neg.Log10.P, color=DEGs.Groups)) +
    
    geom_vline(xintercept=c(-1,1)) +
    geom_hline(yintercept = -log10(0.05)) +
    
    scale_color_manual(values=c("FC Greater than 2"="red", 
                                "FC Less than 2"="blue",
                                "Not Significant FC"="lightgrey")) +
    
    theme(plot.title = element_text(hjust = 0.5, size = 20),
          panel.background = element_rect(fill="white"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(color = "black", fill=NA),
          axis.text = element_text(color = "black"),
          axis.text.x = element_text(angle = 0,hjust=0.5,vjust = 0.5, size = 26),
          axis.text.y = element_text(size = 25),
          axis.title = element_text(size = 30),
          plot.margin = margin(2,2,2,2, unit = "mm")) +
    
    geom_text_repel(aes(x=logFC, y=Neg.Log10.P, label=ToHighlight),size=3.5,
              data=df[idx, ])

 

  return(vplot)
  
}
```



```{r globals_and_loadobj}
# define globals
sys.sep = "/"
data.dir = "data"
seobj.dir = "seobjects"
figs.dir = "figures"

# summarized experiment object names
countsseset.name <- "seset_genecounts_targetaml.rda"
tmmseset.name <- "seset_genetmmfilt_targetaml.rda"
degseset.name <- "seset_degseahack_targetaml.rda"
degfiltset.name <- "sesetfilt_degseahack_targetaml.rda"
maeobj.name <- "mae_targetaml.rda"

# figure filenames
cormap.tile.name <- "cortest_tile.jpg"
cormap.tri.name <- "cortest_triangle.jpg"
hmdeg.name <- "hmdeg_targetaml.jpg"
hmdeg.rowanno.name <- "hmdeg_rowanno_targetaml.jpg"
hmdeg.traintest.name <- "hmdeg_traintest_targetaml.jpg"

# lasso results objects and figures
lasso1.nocofilt.name <- "lasso_rep1_nocofilt_resultlist.rda"
lasso2.cofilt.name <- "lasso_rep2_cofilt1_resultlist.rda"
lasso3.cofilt2.name <- "lasso_rep3_cofilt2_resultlist.rda"
lasso1.figure.name <- "lasso_rep1_features.jpg"

# random forest (noboost) objects and figures
rf.resultlist.name <- "rfiter-noboost_resultlist_smtest.rda"
rf.plot2k.name <- "rf2k_featureimportance.jpg"
rf.plot5k.name <- "rf5k_featureimportance.jpg"
rf.plot10k.name <- "rf10k_featureimportance.jpg"
rf.plotcomposite.name <- "rfall_noboost_featureimportance.jpg"

# standard outputs table
stdtable.name <- "standardtable_mloutputs_summary.rda"

```

```{r load_seobject}
# Load the primary summarized experiment object for experiment
load(paste0(seobj.dir, sys.sep, degseset.name))

# Load the pre-filtered seset
load(paste0(data.dir, sys.sep, degfiltset.name))

```




# Data Preparation
Summarized Experiment objects were created from TARGET AML clinical and RNA-seq data obtained from GDC. Gene counts from STAR 2-Pass alignment were converted using TMM into log counts-per-million scale. Differentially Expressed Genes were determined comparing classifier sample groups in the training sample subset only. Genes were pre-filered on whether at least 5 samples (set-wide) showing counts per mission greater than or equal to 1. 


# Data Summaries and Pre-filtering Samples with Risk Group Available

```{r summarizeclin, eval=TRUE, echo=TRUE}
# Summary statistics and prefiltering samples

#=========================
# summarise the se object
#=========================
message("dim se object")
dim(deg.seset)
# [1] 1984  145
message("table of risk group var")
table(deg.seset$Risk.group)
#     High      Low Standard  Unknown 
#       8       60       69        8
deg.seset$deg.risk <- ifelse(deg.seset$Risk.group=="Low", 0,
                             ifelse(deg.seset$Risk.group %in% c("Standard","High"),1,"NA"))

message("table of binarized risk group")
table(deg.seset$deg.risk)
# 0  1 NA 
# 60 77  8
message("table of risk group x binarized risk group")
table(deg.seset$deg.risk, deg.seset$Risk.group)
#       High Low Standard Unknown
#  0     0  60        0       0
#  1     8   0       69       0
#  NA    0   0        0       8

#=========================================
# pre-filter on available risk group data
#=========================================
degfilt.se <- deg.seset[,which(deg.seset$deg.risk %in% c(0,1))] # subset on deg risk group available
message("dim of filtered se object")
dim(degfilt.se)
# [1] 1984  137
# summarize gender and age at first diagnosis
message("table of gender x binarized risk")
table(degfilt.se$Gender,degfilt.se$deg.risk)
#           0  1
#   Female 29 40
#   Male   31 37
message("chisq test of gender x binarized risk")
chisq.test(table(degfilt.se$Gender,degfilt.se$deg.risk)) # p-value = 0.8044, gender evenly dist
degfilt.se$binom.age <- ifelse(degfilt.se$Age.at.Diagnosis.in.Days >= median(degfilt.se$Age.at.Diagnosis.in.Days), "old" ,"young")
message("table of binarized age-at-diag x binarized risk")
table(degfilt.se$binom.age,degfilt.se$deg.risk)
#         0  1
#  old   32 37
#  young 28 40
message("chisq results of binarized age-at-diag x binarized risk")
chisq.test(table(degfilt.se$binom.age,degfilt.se$deg.risk)) #  p-value = 0.6591, age evenly dist

# save(degfilt.se, file=paste0("data/",degfiltset.name))

```



# Differentially Expressed Genes Summary

```{r summarizedeg, eval=TRUE, echo=TRUE}
# DEG summaries of gene set expr. data, classifier differences, etc.

allgenes <- rownames(degfilt.se)
genemeans.0 <- rowMeans(assay(degfilt.se[,degfilt.se$deg.risk==0]), na.rm=T)
genemeans.1 <- rowMeans(assay(degfilt.se[,degfilt.se$deg.risk==1]), na.rm=T)
lfc.deg <- log2((genemeans.1/(genemeans.0+0.01)))

message("summary of log2FC")
summary(lfc.deg)
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
# -8.4397 -1.0912 -0.6326 -0.4780  0.4111  7.9643     366

length(allgenes[which(lfc.deg < -4)]) # 27
length(allgenes[which(lfc.deg < -2)]) # 144
length(allgenes[which(lfc.deg < 0)]) # 1165
length(allgenes[which(lfc.deg > 0)]) # 412
length(allgenes[which(lfc.deg > 2)]) # 84
length(allgenes[which(lfc.deg > 4)]) # 14

#===========
# DEG plots
#===========
plot(density(lfc.deg[!is.na(lfc.deg)] )) #Error in density.default(lfc.deg) : 'x' contains missing values???
hist(lfc.deg, breaks = 50)
plot(lfc.deg,-1*log10(rowData(degfilt.se)$p.unadj),
     xlab="Log2FC(NotLow_1/Low_0)",
     ylab="-1*log10(padj)")

```


```{r}
DGE <- get(load("data/TARGET_AML_High.Std.Risk_vs_LowRisk_DEGs.rda"))


Ensembl.IDs <- data.frame(ensembl_gene_id=rownames(DGE$fit)) %>% 
  mutate(ensembl_gene_id =gsub("\\.[0-9]{1,}", "", ensembl_gene_id  ))  %>% 
  left_join(., ensembl_ID_conversion(Ensembl.IDs = .$ensembl_gene_id), 
            by="ensembl_gene_id") %>% 
  filter(!duplicated(ensembl_gene_id)) %>%  #1 ensemble ID mapped 2 different gene symbols. for simplicity, pick the first one. 
  mutate_at(vars(external_gene_name,hgnc_symbol), funs(ifelse(is.na(.) | . == "", ensembl_gene_id, .))) %>% #fill in NA values 
  mutate_at(vars(external_gene_name), funs(ifelse(duplicated(.), as.character(ensembl_gene_id), .))) %>% #fix duplicate IDs
  mutate(ensembl_gene_id=factor(ensembl_gene_id,
                                levels = gsub("\\.[0-9]{1,}", "", rownames(DGE$fit)))) %>% #re-order the same as the original input. 
  arrange(ensembl_gene_id) 

head(Ensembl.IDs)
dim(Ensembl.IDs)

#Update the fit to have official hgnc gene symbols. 
identical(gsub("\\.[0-9]{1,}", "", rownames(DGE$fit)), as.character(Ensembl.IDs$ensembl_gene_id )) #TRUE
rownames(DGE$fit$coefficients) <- Ensembl.IDs$external_gene_name
```

```{r message=FALSE, fig.height=6, fig.width=10}
v <- volcano_plot(fit = DGE$fit, cut.off = 5)

# jpeg("TARGET_AML_High.Std.Risk_vs_LowRisk_volcanoPlot.jpeg", height = 6, width = 10, units="in", res=200)
v
# dev.off()
```


# Heatmap Data Set Summaries

```{r degheatmap, eval=TRUE, echo=FALSE, fig.height=7, fig.width=14}
# Heatmap dataset summaries, full dataset and data subsets
require(ComplexHeatmap)
require(circlize)

#=======================
# Heatmap Test vs Train
#=======================
# all data
seset <- degfilt.se
hm_data <- as.matrix(assay(seset))
breaks=seq(min(hm_data),max(hm_data),0.1)
hmcol = colorRamp2(breaks, colorRampPalette(c("green","black","red"))(n=length(breaks)))

```

```{r}
# train data
seset <- degfilt.se[,degfilt.se$exptset.seahack=="train"]
hm_data.train <- as.matrix(assay(seset)[!is.na(lfc.deg),]) %>% 
  t() %>% 
  scale() %>% 
  t()


# breaks=seq(min(hm_data.train),max(hm_data.train),0.01)
# range(hm_data.train) #-6.251179  4.456967
hmcol.tr = colorRamp2(c(-6,-3,-1,0,1,3,6), c("green3", "green2","green1","white",
                                              "red1","red2", "red3")) #(n=299)) #length(breaks)


# hm col annotations can contain complex layered output and colored annotaions
hm_colanno.train <- HeatmapAnnotation(show_legend = TRUE,
                                df = data.frame(sampletype=seset$deg.risk,
                                                gender=seset$Gender,
                                                binom.age=seset$binom.age, 
                                                cyto=seset$Primary.Cytogenetic.Code), 
                                
                                col = list(sampletype = c("0" =  "blue","1" = "red"),
                                           gender = c("Male"="black","Female"="gray"),
                                           binom.age = c("young"="pink","old"="green"), 
                                           cyto=RColorBrewer::brewer.pal(6, name = "Set1") %>% 
                                                  set_names(unique(seset$Primary.Cytogenetic.Code) %>% .[order(.)])),
                                
                                name = "Sample Type",
                                annotation_height = unit(c(0.5, 0.5, 0.5, 0.5), "cm"))

hm.train <- Heatmap(hm_data.train,
        col=hmcol.tr,
        cluster_columns = TRUE,
        cluster_rows = TRUE,
        show_heatmap_legend = TRUE,
        top_annotation = hm_colanno.train,
        name="row z-scores",
        show_row_names = FALSE,
        show_column_names = FALSE,
        column_title = "Train", 
        column_dend_reorder = TRUE,
        row_dend_reorder = TRUE,
        heatmap_legend_param = list(color_bar = "continuous"),
        row_title = "DEGs")

```

```{r, echo=FALSE}
# jpeg("figures/TARGET_AML_TrainingSet_Heatmap.jpeg", height = 7, width = 12, units="in", res=300)
draw(hm.train)
# dev.off()
```

```{r}
# test data
seset <- degfilt.se[,degfilt.se$exptset.seahack=="test"]
hm_data.test <- assay(seset)[!is.na(lfc.deg),] %>% 
  t() %>% 
  scale() %>% 
  t()

# breaks=seq(min(hm_data.test),max(hm_data.test),0.01)
# range(hm_data.test) #-4.922743  5.044380
hmcol.ts = colorRamp2(c(-6,-3,-1,0,1,3,6), c("green3", "green2","green1","white",
                                              "red1","red2", "red3"))

# hm col annotations can contain complex layered output and colored annotaions
hm_colanno.test <- HeatmapAnnotation(show_legend = TRUE,
                                     df = data.frame(sampletype=seset$deg.risk,
                                                gender=seset$Gender,
                                                binom.age=seset$binom.age, 
                                                cyto=seset$Primary.Cytogenetic.Code), 
                                      col = list(sampletype = c("0" =  "blue","1" = "red"),
                                           gender = c("Male"="black","Female"="gray"),
                                           binom.age = c("young"="pink","old"="green"), 
                                           cyto=RColorBrewer::brewer.pal(6, name = "Set1") %>% 
                                                  set_names(unique(seset$Primary.Cytogenetic.Code) %>% .[order(.)])),
                                name = "Sample Type",
                                annotation_height = unit(c(0.5, 0.5, 0.5, 0.5), "cm"))

hm.test <- Heatmap(hm_data.test,
        col=hmcol.ts,
        cluster_columns = TRUE,
        show_heatmap_legend = TRUE,
        top_annotation = hm_colanno.test,
        name="row z-scores",
        show_row_names = FALSE,
        show_column_names = FALSE,
        column_title = "Test", 
        column_dend_reorder = TRUE,
        row_dend_reorder = TRUE,
        heatmap_legend_param = list(color_bar = "continuous"),
        row_title = "DEGs")
```

```{r warning=FALSE, echo=FALSE, fig.width=10}
# jpeg("figures/TARGET_AML_TrainingSet_Heatmap.jpeg", 10, 5, units="in", res=400)
draw(hm.test+hm.train)
# dev.off()
```

```{r}
#==================
# Heatmap All Data
#==================
# Take normally dist data as heatmap matrix
hm_data <- as.matrix(assay(degfilt.se)) %>% 
  t() %>% 
  scale() %>% 
  t()

# hm col annotations can contain complex layered output and colored annotaions
hm_colanno <- HeatmapAnnotation(show_legend = TRUE,
                                     df = data.frame(sampletype=degfilt.se$deg.risk,
                                                gender=degfilt.se$Gender,
                                                binom.age=degfilt.se$binom.age, 
                                                cyto=degfilt.se$Primary.Cytogenetic.Code), 
                                      col = list(sampletype = c("0" =  "blue","1" = "red"),
                                           gender = c("Male"="black","Female"="gray"),
                                           binom.age = c("young"="pink","old"="green"), 
                                           cyto=RColorBrewer::brewer.pal(6, name = "Set1") %>% 
                                                  set_names(unique(degfilt.se$Primary.Cytogenetic.Code) %>% .[order(.)])),
                                name = "Sample Type",
                                annotation_height = unit(c(0.5, 0.5, 0.5, 0.5), "cm"))

# breaks=seq(min(hm_data),max(hm_data),0.1)
# range(hm_data) #-6.178598  5.080216
hmcol = colorRamp2(c(-6,-3,-1,0,1,3,6), c("green3", "green2","green1","white",
                                              "red1","red2", "red3"))

hm <- Heatmap(hm_data,
        col=hmcol,
        cluster_columns = TRUE,
        show_heatmap_legend = TRUE,
        top_annotation = hm_colanno,
        name="row_z_scores",
        show_row_names = FALSE,
        show_column_names = FALSE,
        column_title = "Samples", 
        column_dend_reorder = TRUE,
        row_dend_reorder = TRUE,
        heatmap_legend_param = list(color_bar = "continuous"),
        row_title = "DEGs")

#hm

# jpeg(paste0(figs.dir, sys.sep, "TARGET_AML_full_data_Heatmap.jpeg"), 8, 7, units="in", res=400)
draw(hm)
# dev.off()
```


# Machine Learning: Model Fitting and Assessment

## Standardized Output Table
Results from iterations of model fitting and feature weighting analyses were stored in a single table of all DEGs tested.

```{r standard_table_output}
# Initialize the standard table to hold all test results
standtable = as.data.frame(rowData(degfilt.se))
rownames(standtable) <- standtable$ensembl_gene_id
head(standtable)
```

## Support Vector Machines
The support vector machines (SVM) algorithm was run with the following parameters...
```{r}
# Run 1 -- SVM with linear kernel, no weight filter
svm1 <- runSVM(seed=50, kerneltype="linear", seset = degfilt.se)

# Run 2 -- SVM with linear kernel, 50% weight filter
svm2 <- runSVM(seed=50, kerneltype="linear", seset = degfilt.se,
               weightfilt = 0.5)

# Run 3 -- SVM with linear kernel, no weight filter
svm3 <- runSVM(seed=50, kerneltype="radial", seset = degfilt.se)

# Run 4 -- SVM with linear kernel, 50% weight filter
svm4 <- runSVM(seed=50, kerneltype="radial", seset = degfilt.se,
               weightfilt = 0.5)

#=============================
# form and save results list
#=============================
svm.resultslist = list("svm1"=svm1, "svm2"=svm2, "svm3"=svm3, "svm4"=svm4)
# save(svm.resultslist, file=paste0(data.dir, sys.sep, "svm4reps_resultslist.rda"))

#==================================
# append results (feature weights) 
# to standard output table
#==================================
# <<<<<<< HEAD
# load(paste0(data.dir, sys.sep, "standardtable_mloutputs_summary.rda"))
# =======
#load(paste0(data.dir, sys.sep, "standardtable_mloutputs_summary.rda"))
# >>>>>>> d0d1fd923abc3baadb443df9c8c649b35201a645
cnames = c("svm1_weights","svm2_weights","svm3_weights","svm4_weights")
for(i in 1:4){
  sr <- svm.resultslist[[i]]$weightsvect[1,] %>% set_names(gsub("\\.[0-9]{1,}","", names(.)))
  sv <- sr[order(match(names(sr), rownames(standtable)))]
  if(identical(names(sr), rownames(standtable))){
    standtable$newvar <- sv
    colnames(standtable) <- c(colnames(standtable)[1:ncol(standtable)-1],cnames[i])
  }
}
head(standtable)
# save(standtable, file = paste0(data.dir, sys.sep, "standardtable_mloutputs_summary.rda"))
```


```{r svm_weights_plots}

# define absolute quantile filt
qwfilt <- 0.75

# jpeg(paste0(figs.dir, sys.sep, "bpweights_svm4reps2.jpg"),11,9,units="in",res=400)
par(mfrow=c(2,2),mar=c(5,3,5,2),oma=c(2,2,2,1))
for(i in 1:length(svm.resultslist)){
  wi <- svm.resultslist[[i]]$weightsvect
  wv <- wi[1,]
  names(wv) <- colnames(wi)
  qwi <- quantile(abs(wv),seq(0,1,0.01))[100]  # apply weights filter
  wbp <- wv[abs(wv)>=qwi]
  wbp <- wbp[order(wbp)]
  # append gene symbols to names
  for(l in 1:length(wbp)){
    names(wbp)[l] <- paste0(names(wbp)[l],";\n",rowData(degfilt.se[names(wbp)[l],])$hgnc_symbol)
  }
  barplot(wbp,main=paste0("Rep ",i," Weights"), las=2, cex.names = 0.5)
}
# dev.off()

```


###Permutation Test 

```{r}
#oringinal data labels
labs <- data.frame(USI=degfilt.se$TARGET.USI, 
                   Set=degfilt.se$exptset.seahack,
                   Risk.group=degfilt.se$Risk.group, 
                   deg.risk=degfilt.se$deg.risk)

#define colnames for the random labels in the training set. 
idx <- which(labs$Set=="train")
col.names <- paste("perm",1:5000, sep="_")
class.labels <- c(0,1) # 0 == low, 1 == high/std risk

#create random class labels 
random.labels <- replicate(5000, base::sample(class.labels, size = sum(labs$Set=="train"), 
                                              replace = TRUE))

#update the labels dataframe with the new randomly created classes. 
labs[,col.names] <- labs$deg.risk
labs[idx,col.names] <- random.labels
```

```{r echo=FALSE}
#Sanity check 
# View(labs[,1:100])
# write.csv(labs, "data/svm_permutation_5000_labels.csv", row.names = FALSE)
```

```{r warning=FALSE}
#use sapply to create a list of the results of lasso for each permutation of class labels
permutation.res <- sapply(col.names, function(p){
  print(p)
  
  #a SE object that will be modified with the permutation labels
  seset.per <- degfilt.se 
  
  #update the response variable to be the randomly assigned classes
  seset.per$deg.risk <-  labs[,p]
  
  #run lasso with the randomly assigned group labels svm.perm <-
  svm.perm <- runSVM(seed=as.numeric(str_sub(p, 6))*7, 
         kerneltype="linear", 
         seset =seset.per)

  return(list(svm.perm$testError,svm.perm$log.loss, svm.perm$weightsvect))

}, simplify = FALSE)

# saveRDS(permutation.res, "data/svm_permutation_5000_res.RDS")
# permutation.res <- readRDS("data/svm_")
```

```{r}
test.errors <- sapply(permutation.res, "[[", 1)
log.loss <- sapply(permutation.res, "[[", 2) 
genes.weights <- sapply(permutation.res, "[[", 3)
```

```{r}
random.goodPerformance <- test.errors[test.errors < 0.2]
# permutation.res[names(random.goodPerformance)]
random.goodPerformance %>% length() #only 6 less than 20% test errpr
quantile(test.errors) #min is 13% misclassified
quantile(log.loss)
```

```{r}
# jpeg("figures/svm_test_errors_hist_5000x_permutations.jpg", height = 5, width = 5,  units="in", res=200)
hist(test.errors, breaks = seq(0,1, by=0.025),
     xlab="Test Error", ylab="Number of Occurances", main="Test Errors from Permutation Tests \n with SVM")
abline(v=svm1$testError, col="red", lwd=2)
# dev.off()

# jpeg("figures/svm_log_loss_hist_5000x_permutations.jpg", height = 5, width = 5,  units="in", res=200)
hist(log.loss, breaks = seq(0,1.3, by=0.025), 
     xlab="Test Error", ylab="Number of Occurances", main="Log Loss from Permutation Tests \n with SVM")
abline(v=svm1$log.loss, col="red", lwd=2)
# dev.off()

```


 

## Lasso

Lasso was run with the following parameters...

```{r lasso_allreps, warning=FALSE}
# lasso model fitting reps and analysis
# lasso reps and model assessment
# Note: reps of lasso were performed on DEGs for TARGET pediatric AML samples
#   Models were optimized using the training subset, then assessed using the validation subset
#   Lasso iterations describe runs after performing lasso on subsets of initial DEGs (>1st rep)

# lasso reps
genes.exclude <- c() # running list of genes (selected features) to exclude

rep1 <- runLasso(seset=degfilt.se)
genes.exclude <- c(genes.exclude, names(rep1$nonzero.coef))

rep2 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep2$nonzero.coef))

rep3 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep3$nonzero.coef))

rep4 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep4$nonzero.coef))

rep5 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep5$nonzero.coef))

rep6 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep6$nonzero.coef))

rep7 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude])
genes.exclude <- c(genes.exclude, names(rep7$nonzero.coef))

rep8 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep8$nonzero.coef))

rep9 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep9$nonzero.coef))

rep10 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep10$nonzero.coef))

rep11 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep11$nonzero.coef))

rep12 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep12$nonzero.coef))

rep13 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep13$nonzero.coef))

rep14 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep14$nonzero.coef))

rep15 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep15$nonzero.coef))

lasso.resultslist <- replist <- list(rep1, rep2, rep3, rep4, rep5, rep6, rep7, rep8,
                rep9, rep10, rep11, rep12, rep13, rep14, rep15)

save(lasso.resultslist, file = paste0(data.dir, sys.sep, "lasso_resultslist.rda"))

#======================================================
# Append rep 1-3 coefficients to standard output table
#======================================================
addLassoCoeff <- function(resultslist){
  repcvar<- rep(0, nrow(degfilt.se))
  names(repcvar) <- rownames(degfilt.se) 
  repcoeff <- resultslist$nonzero.coef
  for(i in 1:length(repcoeff)){
    repcvar[names(repcoeff)[i]] <- as.numeric(repcoeff[i])
  }
  names(repcvar) <- gsub("\\.[0-9]{1,}","",names(repcvar))
  return(repcvar)
}

standtable$lasso_coef_rep1 <- addLassoCoeff(rep1)[rownames(standtable)]
standtable$lasso_coef_rep2 <- addLassoCoeff(rep2)[rownames(standtable)]
standtable$lasso_coef_rep3 <- addLassoCoeff(rep3)[rownames(standtable)]
head(standtable)

# save(standtable, file = paste0(data.dir, sys.sep, stdtable.name))

# length(intersect(rownames(standtable[!standtable$lasso_coef_rep1==0,]), rownames(standtable[!standtable$lasso_coef_rep2==0,]))) # 0
# length(intersect(rownames(standtable[!standtable$lasso_coef_rep2==0,]), rownames(standtable[!standtable$lasso_coef_rep3==0,]))) # 0

```


### Model Performance Metrics

```{r lasso_model_performance_plots}
#==========================================
# model performances data frame and graphs
#==========================================

dfp <- as.data.frame(matrix(nrow=15,ncol=5))
colnames(dfp) <- c("rep","tpr","tnr","fdr","for")
dfp$rep <- seq(1,15,1)

postot <- ncol(degfilt.se[,degfilt.se$exptset.seahack=="test" & degfilt.se$deg.risk==1])
falsetot <- ncol(degfilt.se[,degfilt.se$exptset.seahack=="test" & degfilt.se$deg.risk==0])

# True positive rate, TPR = TP/P
tprvar <- c()
for(i in 1:length(replist)){
  tprvar <- c(tprvar, (replist[[i]]$confusionMatrix[2,2]/postot))
}
dfp$tpr <- tprvar

# True negative rate, TNR = TF/F
tnrvar <- c()
for(i in 1:length(replist)){
  tnrvar <- c(tnrvar,(replist[[i]]$confusionMatrix[1,1]/falsetot))
}
dfp$tnr <- tnrvar

# False discovery rate, FDR = 1 - (TP/[TP+FP])
fdrvar <- c()
for(i in 1:length(replist)){
  tp = replist[[i]]$confusionMatrix[2,2]
  fp = replist[[i]]$confusionMatrix[2,1]
  fdrvar <- c(fdrvar, 1-(tp/(tp+fp)))
}
dfp$fdr <- fdrvar

# False omission rate, FOR = 1 - (TN/[TN+FN])
forvar <- c()
for(i in 1:length(replist)){
  tn = replist[[i]]$confusionMatrix[1,1]
  fn = replist[[i]]$confusionMatrix[1,2]
  forvar <- c(forvar, 1-(tn/(tn+fn)))
}
dfp$forvar <- forvar

# graphs

# jpeg(paste0(figs.dir, sys.sep, "modelperf_lassoreps15.jpg"), 5,8,units="in",res=400)
par(mfrow=c(2,1),oma=c(2,2,2,1),mar=c(3,3,2,1))

plot(dfp$rep, dfp$tpr, col="blue", ylim = c(0.6,1), 
     main="Lasso Fitted Model Performances")
lines(dfp$rep, dfp$tpr, col="blue")
points(dfp$rep, dfp$tnr, col="red")
lines(dfp$rep, dfp$tnr, col="red")
abline(h=0.8,col="black",lty=2,lwd=1)

legend("bottomleft", c("TPR","TNR"), 
       xpd = TRUE, horiz = TRUE,
       bty = "n", pch = c(1,1), lwd=c(1,1),
       col = c("red","blue"), cex = 1)

plot(dfp$rep, dfp$fdr, col="forestgreen", ylim=c(0,0.3))
lines(dfp$rep,dfp$fdr, col="forestgreen")
points(dfp$rep,dfp$forvar, col="purple")
lines(dfp$rep,dfp$forvar, col="purple")
abline(h=0.2,col="black",lty=2,lwd=1)

legend("topleft", c("FDR","FOR"), 
       xpd = TRUE, horiz = TRUE,
       bty = "n", pch = c(1,1), lwd=c(1,1),
       col = c("forestgreen","purple"), cex = 1)

mtext("Rep",side=1,line=3,cex=1)
mtext("Value",side=2,line=1,cex=1, outer=TRUE)
# dev.off()
```


###Permutation Test 

```{r}
#oringinal data labels
labs <- data.frame(USI=degfilt.se$TARGET.USI, 
                   Set=degfilt.se$exptset.seahack,
                   Risk.group=degfilt.se$Risk.group, 
                   deg.risk=degfilt.se$deg.risk)

#define colnames for the random labels in the training set. 
idx <- which(labs$Set=="train")
col.names <- paste("perm",1:5000, sep="_")
class.labels <- c(0,1) # 0 == low, 1 == high/std risk

#create random class labels 
random.labels <- replicate(5000, base::sample(class.labels, size = sum(labs$Set=="train"), replace = TRUE))

#update the labels dataframe with the new randomly created classes. 
labs[,col.names] <- labs$deg.risk
labs[idx,col.names] <- random.labels
```

```{r echo=FALSE}
#Sanity check 
# View(labs[,1:100])
# write.csv(labs, "lasso_permutation_5000_labels.csv", row.names = FALSE)
```

```{r warning=FALSE}
#use sapply to create a list of the results of lasso for each permutation of class labels
lassoPermutation.res <- sapply(col.names, function(p){
  print(p)
  
  #a SE object that will be modified with the permutation labels
  seset.per <- degfilt.se 
  
  #update the response variable to be the randomly assigned classes
  seset.per$deg.risk <-  labs[,p]
  
  #run lasso with the randomly assigned group labels
  lasso.perm <- runLasso(seset = seset.per, seed =  as.numeric(str_sub(p, 6))*7)
  return(list(lasso.perm$test.error, lasso.perm$nonzero.coef))
  
}, simplify = FALSE)

# saveRDS(lassoPermutation.res, "data/lasso_permutation_5000_res.RDS")
lassoPermutation.res <- readRDS("data/lasso_permutation_5000_res.RDS")
```

```{r}
rep1$test.error #(7%) # 0.06818182
rep1$nonzero.coef
```

```{r}
L.test.errors <- sapply(lassoPermutation.res, "[[", 1)
L.genes.perm <- sapply(lassoPermutation.res, "[[", 2) 
```

```{r}
L.random.goodPerformance <- test.errors[test.errors < 0.1]
L.random.goodPerformance %>% length() #6

quantile(L.test.errors)
L.genes.perm[names(L.random.goodPerformance)]
# sum(names(lassoPermutation.res$perm_948[[2]]) %in% names(l1.tp$nonzero.coef))
# which(names(lassoPermutation.res$perm_948[[2]]) %in% names(l1.tp$nonzero.coef))

# sapply(lassoPermutation.res[names(random.goodPerformance)], function(x) sum(grepl("ENSG00000078399", names(x[[2]]))))
# sapply(lassoPermutation.res[names(random.goodPerformance)], function(x) sum(names(x[[2]]) %in% names(l1.tp$nonzero.coef)))


```


Notably, of the 6 random trials in lasso that had a test error of less than 10%, 5/6 included HOXA9 with a positive coefficient
Also, for each of these models, the only one gene in common with the ground truth model is HOXA9.

a 0.12% chance (6/5000) that these genes would randomly assign the correct risk group to the test set.  

```{r}
# jpeg("figures/test_errors_hist_5000x_permutations.tiff", height = 5, width = 5,  units="in", res=200)
hist(test.errors, breaks = seq(0,1, by=0.025), 
     xlab="Test Error", ylab="Number of Occurances", main="Test Errors from Permutation Tests \n with Lasso Regression")
abline(v=l1.tp$test.error, col="red", lwd=2)
# dev.off()
```

### Feature Correlations 

```{r lasso_corgene_hm}
# composite correlation heatmaps of lasso selected gene features
# yaxis = rep1 features
# xaxis = rep2, rep3 features

# 0. corhm function
compositeCorHM <- function(seset, corhmname="lasso_hmcorcomp_alldat_rep123.jpg"){
  cordat <- t(assay(seset))
  cordatsym <- cordat
  colnames(cordatsym) <- paste0(rowData(seset)$ensembl_gene_id,"; ",
                                rowData(seset)$hgnc_symbol)
  
  cormat.allsamp <- round(cor(cordat, method="spearman"),3)
  cormatsym.allsamp <- round(cor(cordatsym, method="spearman"),3)
  
  filt1 <- which(rownames(cormat.allsamp) %in% names(rep1$nonzero.coef))
  filt2 <- which(colnames(cormat.allsamp) %in% names(rep2$nonzero.coef))
  filt3 <- which(colnames(cormat.allsamp) %in% names(rep3$nonzero.coef))
  
  call.21 <- cormatsym.allsamp[filt1,filt2]
  call.31 <- cormatsym.allsamp[filt1,filt3]
  
  cordat <- t(assay(seset))
  cordatsym <- cordat
  colnames(cordatsym) <- paste0(rowData(seset)$ensembl_gene_id,"; ",
                                rowData(seset)$hgnc_symbol)
  
  cormat.allsamp <- round(cor(cordat, method="spearman"),3)
  cormatsym.allsamp <- round(cor(cordatsym, method="spearman"),3)
  
  filt1 <- which(rownames(cormat.allsamp) %in% names(rep1$nonzero.coef))
  filt2 <- which(colnames(cormat.allsamp) %in% names(rep2$nonzero.coef))
  filt3 <- which(colnames(cormat.allsamp) %in% names(rep3$nonzero.coef))
  
  call.21 <- cormatsym.allsamp[filt1,filt2]
  call.31 <- cormatsym.allsamp[filt1,filt3]
  
  # colkey
  hm_data = call.21
  breaks=seq(min(hm_data),max(hm_data),0.05)
  hmcol = colorRamp2(breaks,colorRampPalette(c("blue","purple","green","yellow","orange","red"))(n=length(breaks)))
  
  # hm21 -- rep2 genes vs rep1 genes (y-axis)
  hm_data = call.21
  hm21 <- Heatmap(hm_data,col=hmcol,cluster_columns = TRUE,show_heatmap_legend = TRUE,
                  name="Rho", show_row_names = TRUE, show_column_names = TRUE,
                  column_title = "Rep 2 Gene Features", column_dend_reorder = TRUE,
                  row_dend_reorder = TRUE, 
                  heatmap_legend_param = list(color_bar = "continuous"),
                  row_title = "Rep 1 Gene Features",
                  row_names_gp = gpar(fontsize = 8),
                  column_names_gp = gpar(fontsize = 8))
  
  # hm31 -- rep3 genes (x-axis) vs rep1 genes (y-axis)
  hm_data = call.31
  hm31 <- Heatmap(hm_data,col=hmcol,cluster_columns = TRUE,show_heatmap_legend = TRUE,
                  name="Rho", show_row_names = TRUE, show_column_names = TRUE,
                  column_title = "Rep 3 Gene Features", column_dend_reorder = TRUE,
                  row_dend_reorder = TRUE, 
                  heatmap_legend_param = list(color_bar = "continuous"),
                  row_title = "Rep 1 Gene Features",
                  row_names_gp = gpar(fontsize = 8),
                  column_names_gp = gpar(fontsize = 8))
  
  jpeg(paste0(figs.dir, sys.sep, corhmname),12,8,units="in",res=400)
  hm21+hm31
  dev.off()
}

# 1. all data
compositeCorHM(seset=degfilt.se)

# 2. data subsets
# test subset
compositeCorHM(seset=degfilt.se[,degfilt.se$exptset.seahack=="test"],
               corhmname="lasso_hmcorcomp_alltest_rep123.jpg")
# train subset
compositeCorHM(seset=degfilt.se[,degfilt.se$exptset.seahack=="train"],
               corhmname="lasso_hmcorcomp_alltrain_rep123.jpg")

# 3. all data, risk group subsets
# low risk/0
compositeCorHM(seset=degfilt.se[,degfilt.se$deg.risk==0],
               corhmname="lasso_hmcorcomp_alldat0_rep123.jpg")
# std+high risk/1
compositeCorHM(seset=degfilt.se[,degfilt.se$deg.risk==1],
               corhmname="lasso_hmcorcomp_alldat1_rep123.jpg")

```

```{r corplot_lasso2runs}
# Make cor plot of top features selected by 
# initial lasso, and lasso subset 
# (excluding initial selected features)

# corr data, full dataset
cormat <- round(cor(t(assay(degfilt.se)), method="spearman"),3)
melted_cormat <- melt(cormat)
corhist = 
# corr table, filtered genes
goi <- rownames(standtable[!standtable$lasso_coeff==0 | !standtable$lasso_rmCoeff==0,])
cormat_filt <- round(cor(t(assay(degfilt.se[goi,])), method="spearman"),3)
melted_cormat_filt <- melt(cormat_filt)

#====================
# Density Histograms
#====================
corhist.name <- "corplot_hist_all-vs-lassogenes.jpg"
jpeg(paste0(figs.dir, sys.sep, corhist.name), 6,4,units="in",res=400)
plot(density(melted_cormat$value), col=rgb(0.2,0.2,0.8,alpha=0.2), lwd=2, lty=2,
     xlim=c(-1.2,1.2), ylab="Relative Density", xlab="Rho", main="Gene Expr. Correlation Dist.")
lines(density(melted_cormat_filt$value), col=rgb(0.1,0.9,0.2),lwd=3, lty=1)
legend("topright",bty="n",legend=c("All Genes", "Lasso Genes\n(2 reps, with and\nwithout coeff. filt)"), col=c(rgb(0.2,0.2,0.8,alpha=0.2), rgb(0.1,0.9,0.2)), lwd=c(2,3),lty=c(2,1),cex=0.5)
dev.off()

#=======================
# Correlation ggHeatmap
#=======================
colors <- colorRampPalette(c("blue", "green", "yellow", "red"))(42)
colnames(melted_cormat_filt) <- c("Gene Feature 1","Gene Feature 2","Rho")
corhm = ggplot(data = melted_cormat_filt, aes(x=melted_cormat_filt$`Gene Feature 1`, y=melted_cormat_filt$`Gene Feature 2`, fill=melted_cormat_filt$Rho)) + 
  geom_tile() +
  scale_fill_gradientn(colours = colors) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
  ggtitle("Spearman Correlation Results\nLasso Selected Features\n(First run and CoeffFilt run)") +
  xlab("Gene Feature 1") +
  ylab("Gene Feature 2") +
  labs(fill="Rho")

corhm.name = "corplot_hm_lassogenes.jpg"
jpeg(paste0(figs.dir, sys.sep, corhm.name), 7, 7, units="in", res=400)
corhm + scale_colour_gradientn(colours=rainbow(4))
dev.off()

```


## Random Forest
Random forest, a type of ensemble learning method, was applied. We varied the number of trees from 2,000 to 10,000.

```{r random_forest_noboost}
# Random forest model fitting
# varying trees to be 2k, 5k, 10k
require(randomForest)
set.seed(20)

deg.seset <- degfilt.se
# select training data
rfdat.train <- as.data.frame(t(assay(deg.seset[,deg.seset$exptset.seahack=="train"])))
# append binom classes
rfdat.train$class <- as.factor(deg.seset[,deg.seset$exptset.seahack=="train"]$deg.risk)
# form test set as with train set
rfdat.test <- as.data.frame(t(assay(deg.seset[,deg.seset$exptset.seahack=="test"])))
#rfdat.test$class <- as.factor(deg.seset[,deg.seset$exptset.seahack=="test"]$deg.risk)

rf2k <- randomForest(class ~ .,
                     data = rfdat.train,
                     ntree = 2000,
                     importance=TRUE,
                     proximity = TRUE)

rf5k <- randomForest(class ~ .,
                     data = rfdat.train,
                     ntree = 5000,
                     proximity = TRUE)

rf10k <- randomForest(class ~ .,
                     data = rfdat.train,
                     ntree = 10000,
                     proximity = TRUE)
# assess model fit
pred.rf2k <- predict(rf2k, rfdat.test,'response')
pred.rf5k <- predict(rf5k, rfdat.test,'response')
pred.rf10k <- predict(rf10k, rfdat.test,'response')
```

```{r}
t <- rf2k$importance %>% 
  as.data.frame() %>% 
  rownames_to_column("Gene") %>%
  arrange(desc(MeanDecreaseAccuracy)) #%>% 
  # filter(grepl("ENSG00000078399", Gene))
  
head(t, n=20)
```


```{r}
#Find Test Error
cm.2k <- table(observed = as.factor(deg.seset[,deg.seset$exptset.seahack=="test"]$deg.risk), 
      predicted = pred.rf2k)

cm.5k <- table(observed = as.factor(deg.seset[,deg.seset$exptset.seahack=="test"]$deg.risk), 
      predicted = pred.rf5k)

cm.10k <- table(observed = as.factor(deg.seset[,deg.seset$exptset.seahack=="test"]$deg.risk), 
      predicted = pred.rf10k)

rf.resultlist.name = "rf_noboost_2k5k10ktrees_allresultslist.rda"
rf.returnlist <- list('rf2k.results'=list('fitmodel'=rf2k,'conf.matrix'=cm.2k),
                      'rf5k.results'=list('fitmodel'=rf5k,'conf.matrix'=cm.5k),
                      'rf10k.results'=list('fitmodel'=rf10k,'conf.matrix'=cm.10k))
# save(rf.returnlist, file=paste0(data.dir, sys.sep, rf.resultlist.name))

#==============================
# Append results to std. table
#==============================

getRFIvar <- function(rfmodel){
  idf <- importance(rfmodel)
  ivar <- idf[,1]
  names(ivar) <- rownames(idf)
  ivar <- ivar[order(match(names(ivar),rownames(standtable)))]
  if(identical(names(ivar),rownames(standtable))){
    return(ivar)
  } else{
    message("error")
  }
}

standtable$rfnb_2k_MeanDecNodeImp <- as.numeric(getRFIvar(rfmodel=rf2k))
standtable$rfnb_5k_MeanDecNodeImp <- as.numeric(getRFIvar(rfmodel=rf5k))
standtable$rfnb_10k_MeanDecNodeImp <- as.numeric(getRFIvar(rfmodel=rf10k))

# save(standtable, file = paste0(data.dir, sys.sep, stdtable.name))
```

```{r rf_importanceplots}
#================================
# Random forest importance plots
#================================
jpeg(paste0(figs.dir, sys.sep, rf.plotcomposite.name),8,10,units="in",res=400)
par(oma=c(5,5,2,1),mfrow=c(3,1))
import.cutoff = 0.2
rfall <- list(rf2k, rf5k, rf10k)
rftitles <- c("2,000 trees", "5,000 trees", "10,000 trees")
for(i in 1:length(rfall)){
  bpi <- as.vector(round(importance(rfall[[i]]), 2))
  names(bpi) <- rowData(deg.seset)$gene.symbol
  bpi <- bpi[order(bpi)]
  bpi <- bpi[bpi>import.cutoff]
  barplot(bpi, las=2, cex.names = 0.7, main=rftitles[i])
  if(i == 2){
    mtext("Importance",side=2,line=4,cex=1)
  }
  if(i == 3){
    mtext(paste0("Top Features (>",import.cutoff," importance)"), side=1, line=7, cex=1)
  }
}
dev.off()

#====================================
# RF importance by lasso coefficient
#====================================
plot(standtable$lasso_coeff, standtable$rf2ktrees_MeanDecNodeImp)
plot(standtable$lasso_coeff, standtable$rf5ktrees_MeanDecNodeImp)
plot(standtable$lasso_coeff, standtable$rf10ktrees_MeanDecNodeImp)

#par(oma=c(7,3,3,3))
boxplot(standtable[,c("rf2ktrees_MeanDecNodeImp",
                      "rf5ktrees_MeanDecNodeImp",
                      "rf10ktrees_MeanDecNodeImp")],
        las=2)

hist(standtable$rf2ktrees_MeanDecNodeImp)

qrf2k_95quant = quantile(standtable$rf2ktrees_MeanDecNodeImp, seq(0,1,0.05))[20]
nrow(standtable[standtable$rf2ktrees_MeanDecNodeImp>=qrf2k_95quant,]) # 199 genes

nrow(standtable[standtable$rf2ktrees_MeanDecNodeImp>=qrf2k_95quant &
                  !standtable$lasso_coeff==0,]) # 6 genes

nrow(standtable[standtable$rf2ktrees_MeanDecNodeImp>=qrf2k_95quant &
                  (!standtable$lasso_coeff==0|
                     !standtable$lasso_rmCoeff==0),]) # 14 genes

```

## XGboost
Random forest was run again, this time with boosting.

```{r xgboost_allreps}
# XGBoost, or "extreme gradient boost", a type of ensemble learning method
# ref and tutorials: https://cran.r-project.org/web/packages/xgboost/index.html
require(xgboost)

seset <- degfilt.se
rownames(seset) <- paste0(rownames(seset),"; ",rowData(seset)$hgnc_symbol)

# run xgb on training data
xgtrain <- t(assay(seset[,seset$exptset.seahack=="train"]))
xgtrainlabel = seset[,seset$exptset.seahack=="train"]$deg.risk

xgtest <- t(assay(seset[,seset$exptset.seahack=="test"]))
xgtestlabel = seset[,seset$exptset.seahack=="test"]$deg.risk

# rep1
xg1 <- xgboost(data = xgtrain, label = xgtrainlabel, max_depth = 2,
               eta = 1, nthread = 2, nrounds = 2, objective = "binary:logistic")
xg1i <- xgb.importance(feature_names = colnames(xgtrain), model = xg1)

# rep2
xg2 <- xgboost(data = xgtrain, label = xgtrainlabel, max_depth = 50,
               eta = 1, nthread = 2, nrounds = 2, objective = "binary:logistic")
xg2i <- xgb.importance(feature_names = colnames(xgtrain), model = xg2)

# rep3
xg3 <- xgboost(data = xgtrain, label = xgtrainlabel, max_depth = 50,
               eta = 1, nthread = 2, nrounds = 50, objective = "binary:logistic")
xg3i <- xgb.importance(feature_names = colnames(xgtrain), model = xg3)

# rep4 
xg4 <- xgboost(data = xgtrain, label = xgtrainlabel, max_depth = 100,
               eta = 1, nthread = 2, nrounds = 50, objective = "binary:logistic")
xg4i <- xgb.importance(feature_names = colnames(xgtrain), model = xg4)

# rep5
xg5 <- xgboost(data = xgtrain, label = xgtrainlabel, max_depth = 100,
               eta = 1, nthread = 2, nrounds = 100, objective = "binary:logistic")
xg5i <- xgb.importance(feature_names = colnames(xgtrain), model = xg5)

xg.resultslist = list("rep1"=xg1, "rep2"=xg2, "rep3"=xg3, "rep4"=xg4, "rep5"=xg5)
xgi.list <- list("imp1"=xg1i, "imp2"=xg2i, "imp3"=xg3i, "imp4"=xg4i, "imp5"=xg5i)
for(i in 1:length(xg.resultslist)){
  xg.resultslist[[i]]$importance <- xgi.list[[i]]
}

#===========================================
# append performance metrics on test data
#===========================================

postot <- ncol(degfilt.se[,degfilt.se$exptset.seahack=="test" & degfilt.se$deg.risk==1])
falsetot <- ncol(degfilt.se[,degfilt.se$exptset.seahack=="test" & degfilt.se$deg.risk==0])
for(i in 1:length(xg.resultslist)){
  # test set predictions
  predi <- predict(xg.resultslist[[i]], xgtest) # testset predictions
  pbi <- ifelse(pred1>0.5, 1, 0) # binarized probabilities
  cmi = table(pb1, xgtestlabel) # confusion matrix
  
  # performance metrics
  tp = cmi[2,2]
  fp = cmi[2,1]
  tn = cmi[1,1]
  fn = cmi[1,2]
  
  mean.err <- mean(as.numeric(pred1 > 0.5) != xgtestlabel) # mean.err
  tpri = (cmi[2,2]/postot)
  tnri = (cmi[1,1]/falsetot)
  fdri = 1-(tp/(tp+fp))
  forvali = 1-(tn/(tn+fn))
  
  xg.resultslist[[i]]$performance_testset <- list("confusionMatrix"=cmi,
                                              "mean_err"=mean.err,
                                              "tpr"=tpri,
                                              "tnr"=tnri,
                                              "fdr"=fdri,
                                              "for"=forvali)
}

# testset performances df
dfxgp <- matrix(xg.resultslist[[1]]$performance_testset[2:6], nrow=1)
for(i in 2:length(xg.resultslist)){
  dfxgp <- rbind(dfxgp,matrix(xg.resultslist[[i]]$performance_testset[2:6], nrow=1))
}
colnames(dfxgp) <- c(names(xg.resultslist[[1]]$performance_testset[2:6]))
rownames(dfxgp) <- c(paste0("rep",seq(1,length(xg.resultslist))))

xg.resultslist[["testperfdf"]] <- dfxgp

#===================
# save resultslist
#===================
save(xg.resultslist, file=paste0(data.dir, sys.sep, "xgb_resultslist.rda"))

#=================================
# append results to standard table
#=================================
# note: performances no different across reps

load(paste0(data.dir, sys.sep, stdtable.name))

# only append importances, though other metrics available
# e.g. gain, cover, and freq

cnames <- c("xg1_imp", "xg2_imp", "xg3_imp", "xg4_imp", "xg5_imp")
for(i in 1:length(cnames)){
  xgii <- xg.resultslist[[i]]$importance
  xgiiv <- xgii$Importance
  names(xgiiv) <- xgii$Feature
  standtable$newvar <- 0
  for(l in 1:length(xgiiv)){
    standtable[gsub(";.*","",names(xgiiv)[l]),]$newvar <- xgiiv[l]
  }
  colnames(standtable)[length(colnames(standtable))] <- cnames[i]
}

save(standtable, file = paste0(data.dir, sys.sep, stdtable.name))

```

```{r xgplot}
# plot feature importances across reps

plotwidth = 7
plotheight = 6

jpeg(paste0(figs.dir, sys.sep, "xgb1_compimportance.jpg"), plotwidth, plotheight, units="in", res=400)
xgb.ggplot.importance(importance_matrix = xg.resultslist[[1]]$importance, main="Rep 1 Importance")
dev.off()

jpeg(paste0(figs.dir, sys.sep, "xgb2_compimportance.jpg"), plotwidth, plotheight, units="in", res=400)
xgb.ggplot.importance(importance_matrix = xg.resultslist[[2]]$importance, main="Rep 2 Importance")
dev.off()

jpeg(paste0(figs.dir, sys.sep, "xgb3_compimportance.jpg"), plotwidth, plotheight, units="in", res=400)
xgb.ggplot.importance(importance_matrix = xg.resultslist[[3]]$importance, main="Rep 3 Importance")
dev.off()

jpeg(paste0(figs.dir, sys.sep, "xgb4_compimportance.jpg"), plotwidth, plotheight, units="in", res=400)
xgb.ggplot.importance(importance_matrix = xg.resultslist[[4]]$importance, main="Rep 4 Importance")
dev.off()

jpeg(paste0(figs.dir, sys.sep, "xgb5_compimportance.jpg"), plotwidth, plotheight, units="in", res=400)
xgb.ggplot.importance(importance_matrix = xg.resultslist[[5]]$importance, main="Rep 5 Importance")
dev.off()

```


# Machine Learning Summary

```{r write_standtable_csv}
write.csv(standtable, file=paste0(data.dir, sys.sep, "standouttable.csv"))
```



#Gene Ontology 

```{r}
# BiocManager::install("TxDb.Hsapiens.UCSC.hg38.knownGene")
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(goseq)
library(gage)

data("kegg.gs")
kg.hsa=kegg.gsets("hsa")

```

```{r message=FALSE, warning=FALSE}
supportedOrganisms() %>%
  filter(grepl("hg19|hg38", Genome))
```

## GO and KEGG Enrichment for all DEGs

```{r}
#All input genes from the 
genes <- rownames(DGE$voomTransformation$E) %>% 
  gsub("\\.[0-9]{1,}", "", .)

#DEGs present in the genes 'universe'
all.degs <- ifelse(genes %in% standtable$ensembl_gene_id , 1,0) %>% 
  set_names(genes)
table(all.degs)

all.pwf <- nullp(all.degs, "hg38", "ensGene")

all.GO <- goseq(all.pwf, "hg38", "ensGene",
               test.cats=c("GO:BP", "GO:MF"), 
               method="Wallenius") %>%
  mutate(FDR=p.adjust(over_represented_pvalue, method = "BH")) %>%
  filter(FDR < 0.1) %>% 
  filter(numInCat > 20 & numInCat < 450)

head(all.GO) 
dim(all.GO) #518
```

```{r}
all.KEGG <- goseq(all.pwf, "hg38", "ensGene",
               test.cats=c("KEGG"), 
               method="Wallenius") %>%
  mutate(FDR=p.adjust(over_represented_pvalue, method = "BH")) %>%
  filter(FDR < 0.1) %>% 
  filter(numInCat > 20 & numInCat < 450) %>% 
  left_join(.,  data.frame(PathwayName=names(kg.hsa$kg.sets)) %>% 
              mutate(Pathway_Accession=gsub("hsa","", PathwayName) %>% 
                       gsub("(^[0-9]{5})\\D+[A-Za-z0-9].+", "\\1", .)), 
            by=c("category"="Pathway_Accession"))

head(all.KEGG)
dim(all.KEGG)
# write.csv(all.KEGG, "data/TARGET_AML_High.Std.Risk_vs_LowRisk_KEGG.csv", row.names = FALSE)
```

##Examination of Selected Features by Lasso, Weight, or Importance 

```{r}
lasso.features <- names(rep1$nonzero.coef) %>% 
  gsub("\\.[0-9]{1,}","", .)

lasso.1_All <-  ifelse(genes %in% lasso.features , 1,0) %>% 
  set_names(genes)
table(lasso.1_All)

lasso.1_All.pwf <- nullp(lasso.1_All, "hg38", "ensGene")

lasso.1_DEGs <- ifelse( standtable$ensembl_gene_id %in% lasso.features , 1,0) %>% 
  set_names(standtable$ensembl_gene_id )
table(lasso.1_DEGs)

lasso.1_DEGs.pwf <- nullp(lasso.1_DEGs, "hg38", "ensGene")
```

```{r}
lasso.1_All.GO <- goseq(lasso.1_All.pwf, "hg38", "ensGene",
               test.cats=c("GO:BP", "GO:MF"), 
               method="Wallenius") %>%
  mutate(FDR=p.adjust(over_represented_pvalue, method = "BH")) %>%
  # filter(FDR < 0.1) %>% 
  filter(numInCat > 20 & numInCat < 450) %>%
  arrange(desc(numDEInCat), over_represented_pvalue)

head(lasso.1_All.GO)
```

```{r}
lasso.1_DEGs.GO <- goseq(lasso.1_DEGs.pwf, "hg38", "ensGene",
               test.cats=c("GO:BP", "GO:MF"), 
               method="Wallenius") %>%
  mutate(FDR=p.adjust(over_represented_pvalue, method = "BH")) %>%
  # filter(FDR < 0.1) %>% 
  filter(numInCat > 20 & numInCat < 450) %>% 
  arrange(desc(numDEInCat), over_represented_pvalue)

head(lasso.1_DEGs.GO)
```



# Results Summaries


# R Env log

```{r}
sessionInfo()
```

