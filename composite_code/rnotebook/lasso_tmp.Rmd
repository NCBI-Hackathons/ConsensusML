---
title: "Discovery of Acute Myeloid Leukemia Biomarkers using Ensemble Machine Learning"
author:
- Sean Maden
- Jenny Smith
output: html_notebook

---


#Set-up 

```{r setup, include=FALSE}
require(knitr)
# knitr::opts_knit$set(root.dir = '~/Documents/GitHub/RNAseq_Cancer_Biomarkers/')
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=50),
                      tidy=TRUE, 
                      fig.align='center', 
                      fig.height=5, 
                      fig.width=8, 
                      dpi = 600,
                      echo=FALSE,
                      eval=TRUE)

options(stringsAsFactors = FALSE)
```

```{r libraries, eval=TRUE, echo=FALSE, message=FALSE}
# get dependency libraries

#==========
# install
#==========
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install(c("edgeR","MLSeq","DESeq2"))

#======
# load
#======
library(plyr)
library(mlr)
library(magrittr)
library(ggplot2)
library(glmnet)
library(ROSE)
library(stringr)
library(dplyr)
library(tibble)
library(tidyr)
library(limma)
library(edgeR)
library(MLSeq)
library(DESeq2)
library(MLmetrics)
# library(xlsx) #java image no found??
library(VennDiagram)
library(SummarizedExperiment)
library(GenomicRanges)
library(circlize)
library(reshape2)
library(biomaRt)
# library(EnsDb.Hsapiens.v75)



```

```{r}
# ML functions
# Lasso
runLasso <- function(seset, seed=2019, type.measure="class"){
  # credit base code: Jenny Smith
  # runLasso
  # Fit a model using penalized regression with lasso
  # Arguments:
  # * sese: Valid summarized experiment object
  # * seed: (int) set seed for randomization
  # Returns:
  # * resultslist (list) : Results of lasso fit
  
  require(glmnet)
  require(SummarizedExperiment)
  require(MLmetrics)
  set.seed(seed) 
  
  gene.names = rownames(rowData(seset))
  var.classifier = seset$deg.risk
  df = t(assay(seset))
  
  #define train/test sets 
  train.names = colnames(assay(seset[,seset$exptset.seahack=="train"]))
  test.names = colnames(assay(seset[,seset$exptset.seahack=="test"]))
  
  #define predictors and response variables
  response <- var.classifier
  predictors <- gene.names
  
  y <- factor(response); names(y) <- colnames(assay(seset)) # response var obj
  x = df[,predictors] # genes of interest
  contrast <- contrasts(y)
  
  #lambda values
  grid <- 10^ seq(10,-2, length=100)
  
  #standardize is an option to mean center. 
  #Don't use since we want to keep the natural variation and expression is already normalized for sample to  sample comparisons. 
  standardize = FALSE
  
  fit <- glmnet(x[train.names,], y[train.names], family = "binomial", alpha=1, 
                standardize = standardize, lambda = grid, intercept = FALSE)
  
  # use cross-validation on the training model.CV only for lambda
  cv.fit <- cv.glmnet(x[train.names,], y[train.names], family = "binomial",
                      type.logistic="modified.Newton", standardize = standardize,
                      lambda = grid, alpha=1, nfolds = length(train.names), #LOOCV 
                      type.measure = type.measure, intercept = FALSE)
  
  #Select lambda min.
  lambda.min <- cv.fit$lambda.min
  
  #predict the classes
  pred.class <- predict(fit, newx = x[test.names,], type="class", s=lambda.min)
  pred.prob <- predict(fit, newx = x[test.names,], type="response", s=lambda.min)
  
  #find the test error
  tab <- table(pred.class,y[test.names])
  testError <- mean(pred.class != y[test.names]) #how many predicted classes were incorrect
  
  #Fit the full dataset.
  final <- glmnet(x, y,family = "binomial", standardize = standardize, 
                  lambda = grid, alpha = 1, intercept = FALSE)
  
  #Extract the coefficients
  coef <- predict(final, type="coefficients", s=lambda.min)
  idx <- which(!as.numeric(coef)==0)
  nonZero <- coef[idx,]
  
  #Results 
  resultslist <- list("training.set"=train.names, 
                      "testing.set"=test.names, 
                      "contrast"=contrast, 
                      "train.fit"=fit, 
                      "cv.fit"= cv.fit,
                      "pred.probability"=pred.prob,
                      "confusionMatrix"=tab,
                      "test.error"=testError, 
                      "final.model"= final, 
                      "nonzero.coef"=nonZero, 
                      "seed"=seed)

  return(resultslist)
}



# SVM
runSVM <- function(seed,kerneltype="linear",trainset,trainclasses,
                   testset,testclasses, weightfilt=FALSE){
  # credit base code: Sean Maden
  # run SVM optimization
  # Arguments
  #   * seed : set seed (int) for randomization
  #   * kerneltype : (str) valid kernel type class for SVM (e.g. 'linear', 'radial', etc.)
  #   * trainset : training dataset (excluding sample classes)
  #   * trainclasses : classes for training sampels (vector) with 1:1 correspondence 
  #       with trainset rows
  #   * testset : test data (data frame or matrix), excluding classes
  #   * testclasses : classes for test samples (vector), with 1:1 row:pos correspondence
  #   * weightfilt : (FALSE or numeric float) top fraction weights to use in model 
  #       (if FALSE, then all weights used) 
  # Returns
  #   * rl (list) : list containing model fitted, predictions, and performacne metrics
  require(e1071); require(ROCR)
  rl <- list(); str.options <- ""
  set.seed(seed)
  ndtr <- trainset
  ndte <- testset
  ndtr.classes <- trainclasses
  ndte.classes <- testclasses
  
  # train svm model
  svm_model <- svm(as.factor(ndtr.classes)~., 
                   data=ndtr, 
                   method="C-classification", 
                   kernel=kerneltype)
  weightsvect <- ndtr.weights <- t(svm_model$coefs) %*% svm_model$SV
  if(weightfilt){
    str.options <- c(str.options,paste0("weight filt = ",weightfilt))
    # order training data on relative weights
    ndtr.weightsort <- ndtr[,rev(order(abs(ndtr.weights)))]
    # select only top proportion weights
    nweight.col = round(ncol(ndtr.weightsort)*weightfilt,0)
    ndtr.weightfilt <- ndtr.weightsort[,c(1:nweight.col)]
    str.options <- c(str.options,paste("cols_retained:",colnames(ndtr.weightfilt),collapse=";"))
    # redefine training set, rerun SVM optimization
    ndtr <- ndtr.weightfilt
    svm_model <- svm(as.factor(ndtr.classes)~., 
                     data=ndtr, 
                     method="C-classification", 
                     kernel=kerneltype)
  } else{
    str.options <- c(str.options,"no weight filt")
  }
  pred_train <- predict(svm_model, ndtr, decision.values = TRUE)
  pred_test <- predict(svm_model, ndte, decision.values = TRUE)
  # get performance metrics
  pred <- prediction(as.numeric(attr(pred_test,"decision.values")),ndte.classes)
  perf <- performance(pred,"tpr","fpr")
  ppred <- pred_test[pred_test==1]; 
  tppred <- ndte.classes[pred_test==1]
  ppred <- as.numeric(as.character(ppred))
  testprec <- length(ppred[ppred==tppred])/length(ppred) # test precision
  rposi <- ndte.classes==1
  rtpred <- ndte.classes[rposi]; 
  rppred <- pred_test[rposi]
  rppred <- as.numeric(as.character(rppred))
  testrec <- length(rppred[rppred==1])/length(rppred) # test recall
  
  # return model, pred's, and performance metrics
  rl <- list(str.options,
             svm_model,
             weightsvect,
             pred_train,
             pred_test,
             perf,
             tppred,
             testprec,
             testrec)
  names(rl) <- c("options_string",
                 "svm_model",
                 "weightsvect",
                 "predictions_train",
                 "predictions_test",
                 "performance_test",
                 "TPR_test",
                 "precision_test",
                 "recall_test"
  )
  return(rl)
  
}

```

```{r utilityfunctions, eval=FALSE}
# utilities for data summaries and visualization

#==============================
# differential gene expression
#==============================
voom_DE <- function(counts.df, ref, pheno){
  # credit base code: Jenny Smith
  #counts.df is a dataframe with count data, with genes as rownames
  #pheno is a character vector with patient IDs as names, and the status for each in each group(eg pos,neg)
  require(edgeR)
  library(limma)
  
  #ensure correct order for both expn and counts.df
  samples <- intersect(names(pheno), colnames(counts.df))
  pheno <- pheno[samples]
  counts.df <- counts.df[,samples]
  
  #define phenotype groups (eg control vs treatment)
  groups <- unique(pheno)
  groups <- c(groups[groups != ref], ref) #order so that reference is second 
  pheno.f <- factor(pheno, levels=groups)
  
  #create DGE object 
  dge <- DGEList(counts = counts.df, group = pheno.f)
  
  #filter genes that have greater than 1 CPM in at least 5% of samples
  keep.dge <- rowSums(cpm(dge) >= 1) > (0.05*ncol(counts.df)) 
  dge <- dge[keep.dge,]
  dge <- calcNormFactors(dge) #TMM normalize
  
  #create design matrix for DE contrasts
  design <- model.matrix(~0 + pheno.f, data=dge$samples)
  colnames(design) <- levels(pheno.f)
  cont.matrix <- makeContrasts(contrasts = paste(groups, collapse = "-"), levels = design)
  
  #voom transform
  v.lv <- voom(dge, design, plot = FALSE)
  
  #fit linear model and compute moderated t-statistics using empirical Bayes
  fit <- lmFit(v.lv, design)
  fit <- contrasts.fit(fit, contrasts = cont.matrix)
  fit <- eBayes(fit)
  #extract the differentially expressed genes with abs log2FC >= 1 and FRD < 0.05
  table <- topTable(fit, number = 20000, p.value=0.05, adjust.method="BH", sort.by="P",lfc=1)
  


  list <- list(design, v.lv, fit, table)
  names(list) <- c("desingMatrix", "voomTransformation", "fit", "DEGs")
  return(list)
}

#=================
# categorize DEGs
#=================
catExpnData <- function(filenames,regex, cols, header=FALSE,removeFirstLine=FALSE, sep="\t"){
  #credit base code: Jenny Smith
  # Purpose: Concatenate the expression data-sets downloaded from TCGA/TARGET from GDC or any patient level data
  #eg. each individual patient has a single expression-file 
  
  library(magrittr)
  options(stringsAsFactors = FALSE)
  #filenames is a character vector of all filenames. 
  #regex is a string with the pattern to extract the patient ID , eg "^.+(Kasumi|MV4)", from filenames 
  #cols is the character vector or numeric vector of the columns to select and concatenate. 
  
  #function to read in a file and split it into a list of individual columns 
  extract_cols <-function(filename,cols,rmFirstLine=FALSE){
    
    if(all(rmFirstLine & header)){
      aFile <- readLines(filename)[-1] #remove first line with extra info. 
      aFile <- str_split_fixed(aFile, pattern = "\t",n = length(cols)) %>% #split into a matrix
        set_colnames(.[1,] ) %>%  #set colnames from the first line 
        .[-1, ] #remove the header row from matrix
    }else{
      aFile <- read.delim(filename, sep=sep, header=header, as.is=TRUE)
    }
    
    output <- list()
    for ( k in 1:length(cols)){
      colname <- cols[k]
      col <- aFile[,colname]
      output[[colname]] <- col
    }
    return(output)
  }
  
  #function to combine the elements of the list of columns into a matrix.
  combineColumns <- function(extract_cols.res,colname){
    sapply(extract_cols.res, '[[', colname)
  }
  
  #define the IDs for the columns
  IDs <- gsub(regex, "\\1", filenames)
  
  columns <- lapply(filenames,extract_cols,cols=cols, rmFirstLine=removeFirstLine) %>%
    set_names(IDs)
  
  catedMatrices <- lapply(cols, combineColumns, extract_cols.res=columns)  %>%
    set_names(cols)
  
  
  return(catedMatrices)
}

#==============
# volcano plot
#==============
volcano_plot <- function(fit, cut.off=4, label.offset=0.5){
  require(ggrepel)
  # credit base code: Jenny Smith
  #fit is the eBayes fit from limma. 
  
  df <- data.frame(logFC=fit$coefficients[,1],
                   pValue=fit$p.value[,1],
                   FDR=p.adjust(fit$p.value[,1], method="BH"),
                   MeanExpression=fit$Amean) %>%
      rownames_to_column("Gene") %>%
      mutate(Neg.Log10.P= -log10(pValue),
             DEGs.Groups=case_when(
                  logFC > 1.0 & pValue < 0.05 ~ "FC Greater than 2",
                  logFC < -1.0 & pValue < 0.05 ~ "FC Less than 2",
                  TRUE ~ "Not Significant FC"))

  
  #Select differentially expressed genes to highlight in the plot. 
  ToHighlight <- df[abs(df$logFC) > cut.off & df$FDR < 0.05, "Gene"] 
  idx <- which(abs(df$logFC) > cut.off & df$FDR < 0.05)
  
  vplot <- ggplot(df, aes(x=logFC, y=Neg.Log10.P)) + 
    geom_point(data = filter(df, DEGs.Groups == "Not Significant FC"), 
               mapping = aes(x=logFC, y=Neg.Log10.P, color=DEGs.Groups), alpha=0.65)  +
    
    geom_point(data= filter(df, grepl("2", DEGs.Groups)), 
               mapping = aes(x=logFC, y=Neg.Log10.P, color=DEGs.Groups)) +
    
    geom_vline(xintercept=c(-1,1)) +
    geom_hline(yintercept = -log10(0.05)) +
    
    scale_color_manual(values=c("FC Greater than 2"="red", 
                                "FC Less than 2"="blue",
                                "Not Significant FC"="lightgrey")) +
    
    theme(plot.title = element_text(hjust = 0.5, size = 20),
          panel.background = element_rect(fill="white"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(color = "black", fill=NA),
          axis.text = element_text(color = "black"),
          axis.text.x = element_text(angle = 0,hjust=0.5,vjust = 0.5, size = 26),
          axis.text.y = element_text(size = 25),
          axis.title = element_text(size = 30),
          plot.margin = margin(2,2,2,2, unit = "mm")) +
    
    geom_text_repel(aes(x=logFC, y=Neg.Log10.P, label=ToHighlight),size=3.5,
              data=df[idx, ])

 

  return(vplot)
  
}
```



```{r globals_and_loadobj}
# define globals
sys.sep = "/"
data.dir = "data"
seobj.dir = "seobjects"
figs.dir = "figures"

# summarized experiment object names
countsseset.name <- "seset_genecounts_targetaml.rda"
tmmseset.name <- "seset_genetmmfilt_targetaml.rda"
degseset.name <- "seset_degseahack_targetaml.rda"
degfiltset.name <- "sesetfilt_degseahack_targetaml.rda"
maeobj.name <- "mae_targetaml.rda"

# figure filenames
cormap.tile.name <- "cortest_tile.jpg"
cormap.tri.name <- "cortest_triangle.jpg"
hmdeg.name <- "hmdeg_targetaml.jpg"
hmdeg.rowanno.name <- "hmdeg_rowanno_targetaml.jpg"
hmdeg.traintest.name <- "hmdeg_traintest_targetaml.jpg"

# lasso results objects and figures
lasso1.nocofilt.name <- "lasso_rep1_nocofilt_resultlist.rda"
lasso2.cofilt.name <- "lasso_rep2_cofilt1_resultlist.rda"
lasso3.cofilt2.name <- "lasso_rep3_cofilt2_resultlist.rda"
lasso1.figure.name <- "lasso_rep1_features.jpg"

# random forest (noboost) objects and figures
rf.resultlist.name <- "rfiter-noboost_resultlist_smtest.rda"
rf.plot2k.name <- "rf2k_featureimportance.jpg"
rf.plot5k.name <- "rf5k_featureimportance.jpg"
rf.plot10k.name <- "rf10k_featureimportance.jpg"
rf.plotcomposite.name <- "rfall_noboost_featureimportance.jpg"

# standard outputs table
stdtable.name <- "standardtable_mloutputs_summary.rda"

```

```{r load_seobject}
# Load the primary summarized experiment object for experiment
load(paste0(seobj.dir, sys.sep, degseset.name))

# Load the pre-filtered seset
load(paste0(data.dir, sys.sep, degfiltset.name))

```




# Data Preparation
Summarized Experiment objects were created from TARGET AML clinical and RNA-seq data obtained from GDC. Gene counts from STAR 2-Pass alignment were converted using TMM into log counts-per-million scale. Differentially Expressed Genes were determined comparing classifier sample groups in the training sample subset only. Genes were pre-filered on whether at least 5 samples (set-wide) showing counts per mission greater than or equal to 1. 


# Data Summaries and Pre-filtering Samples with Risk Group Available

```{r summarizeclin, eval=TRUE, echo=TRUE}
# Summary statistics and prefiltering samples

#=========================
# summarise the se object
#=========================
message("dim se object")
dim(deg.seset)
# [1] 1984  145
message("table of risk group var")
table(deg.seset$Risk.group)
#     High      Low Standard  Unknown 
#       8       60       69        8
deg.seset$deg.risk <- ifelse(deg.seset$Risk.group=="Low", 0,
                             ifelse(deg.seset$Risk.group %in% c("Standard","High"),1,"NA"))

message("table of binarized risk group")
table(deg.seset$deg.risk)
# 0  1 NA 
# 60 77  8
message("table of risk group x binarized risk group")
table(deg.seset$deg.risk, deg.seset$Risk.group)
#       High Low Standard Unknown
#  0     0  60        0       0
#  1     8   0       69       0
#  NA    0   0        0       8

#=========================================
# pre-filter on available risk group data
#=========================================
degfilt.se <- deg.seset[,which(deg.seset$deg.risk %in% c(0,1))] # subset on deg risk group available
message("dim of filtered se object")
dim(degfilt.se)
# [1] 1984  137
# summarize gender and age at first diagnosis
message("table of gender x binarized risk")
table(degfilt.se$Gender,degfilt.se$deg.risk)
#           0  1
#   Female 29 40
#   Male   31 37
message("chisq test of gender x binarized risk")
chisq.test(table(degfilt.se$Gender,degfilt.se$deg.risk)) # p-value = 0.8044, gender evenly dist
degfilt.se$binom.age <- ifelse(degfilt.se$Age.at.Diagnosis.in.Days >= median(degfilt.se$Age.at.Diagnosis.in.Days), "old" ,"young")
message("table of binarized age-at-diag x binarized risk")
table(degfilt.se$binom.age,degfilt.se$deg.risk)
#         0  1
#  old   32 37
#  young 28 40
message("chisq results of binarized age-at-diag x binarized risk")
chisq.test(table(degfilt.se$binom.age,degfilt.se$deg.risk)) #  p-value = 0.6591, age evenly dist

# save(degfilt.se, file=paste0("data/",degfiltset.name))

```



# Differentially Expressed Genes Summary

```{r summarizedeg, eval=TRUE, echo=TRUE}
# DEG summaries of gene set expr. data, classifier differences, etc.

allgenes <- rownames(degfilt.se)
genemeans.0 <- rowMeans(assay(degfilt.se[,degfilt.se$deg.risk==0]), na.rm=T)
genemeans.1 <- rowMeans(assay(degfilt.se[,degfilt.se$deg.risk==1]), na.rm=T)
lfc.deg <- log2((genemeans.1/(genemeans.0+0.01)))

message("summary of log2FC")
summary(lfc.deg)
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
# -8.4397 -1.0912 -0.6326 -0.4780  0.4111  7.9643     366

length(allgenes[which(lfc.deg < -4)]) # 27
length(allgenes[which(lfc.deg < -2)]) # 144
length(allgenes[which(lfc.deg < 0)]) # 1165
length(allgenes[which(lfc.deg > 0)]) # 412
length(allgenes[which(lfc.deg > 2)]) # 84
length(allgenes[which(lfc.deg > 4)]) # 14

#===========
# DEG plots
#===========
plot(density(lfc.deg[!is.na(lfc.deg)] )) #Error in density.default(lfc.deg) : 'x' contains missing values???
hist(lfc.deg, breaks = 50)
plot(lfc.deg,-1*log10(rowData(degfilt.se)$p.unadj),
     xlab="Log2FC(NotLow_1/Low_0)",
     ylab="-1*log10(padj)")

```


```{r}
ensembl_ID_conversion <- function(Ensembl.IDs){

  lib.path <- strsplit(version[['version.string']], ' ')[[1]][3] %>% 
    gsub("\\.[0-9]{1,}$", "", . )  %>% 
    paste0("/home/jlsmith3/R/x86_64-pc-linux-gnu-library/", .)
  
  library(biomaRt, lib.loc = lib.path)
  
 
  mart <- useEnsembl(biomart = "ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl") 
  attr.mart <-  c("ensembl_gene_id", "external_gene_name","hgnc_symbol")
  
  res <- getBM(attributes = attr.mart,
                    filters = "ensembl_gene_id",
                    values = Ensembl.IDs,
                    mart = mart)
  
  return(res)
}
```


```{r}
DGE <- get(load("data/TARGET_AML_High.Std.Risk_vs_LowRisk_DEGs.rda"))


Ensembl.IDs <- data.frame(ensembl_gene_id=rownames(DGE$fit)) %>% 
  mutate(ensembl_gene_id =gsub("\\.[0-9]{1,}", "", ensembl_gene_id  ))  %>% 
  left_join(., ensembl_ID_conversion(Ensembl.IDs = .$ensembl_gene_id), 
            by="ensembl_gene_id") %>% 
  filter(!duplicated(ensembl_gene_id)) %>%  #1 ensemble ID mapped 2 different gene symbols. for simplicity, pick the first one. 
  mutate_at(vars(external_gene_name,hgnc_symbol), funs(ifelse(is.na(.) | . == "", ensembl_gene_id, .))) %>% #fill in NA values 
  mutate_at(vars(external_gene_name), funs(ifelse(duplicated(.), as.character(ensembl_gene_id), .))) %>% #fix duplicate IDs
  mutate(ensembl_gene_id=factor(ensembl_gene_id,
                                levels = gsub("\\.[0-9]{1,}", "", rownames(DGE$fit)))) %>% #re-order the same as the original input. 
  arrange(ensembl_gene_id) 

head(Ensembl.IDs)
dim(Ensembl.IDs)

#Update the fit to have official hgnc gene symbols. 
identical(gsub("\\.[0-9]{1,}", "", rownames(DGE$fit)), as.character(Ensembl.IDs$ensembl_gene_id )) #TRUE
rownames(DGE$fit$coefficients) <- Ensembl.IDs$external_gene_name
```

```{r message=FALSE, fig.height=6, fig.width=10}
v <- volcano_plot(fit = DGE$fit, cut.off = 5)

# jpeg("TARGET_AML_High.Std.Risk_vs_LowRisk_volcanoPlot.jpeg", height = 6, width = 10, units="in", res=200)
v
# dev.off()
```



 
## Lasso
Lasso was run with the following parameters...

```{r warning=FALSE}
#permutation with a single ground truth class assignment. 
l1.tp <- runLasso(seset = degfilt.se)

l1.tp.auc <- runLasso(seset = degfilt.se,type.measure = "auc")
```

```{r}
l1.tp$cv.fit$lambda.min
l1.tp$test.error
l1.tp$confusionMatrix

cbind(l1.tp$pred.probability,l1.tp.auc$pred.probability, degfilt.se$deg.risk[degfilt.se$exptset.seahack == "test"])

l1.tp$nonzero.coef#13
```

```{r}
l1.tp.auc$cv.fit$lambda.min
l1.tp.auc$test.error
l1.tp.auc$confusionMatrix

l1.tp.auc$nonzero.coef #22
```

```{r}
venn.diagram(x=list("class"=names(l1.tp$nonzero.coef), "auc"=names(l1.tp.auc$nonzero.coef)),filename="class_vs_auc.tiff")
```


```{r}
#oringinal data labels
labs <- data.frame(USI=degfilt.se$TARGET.USI, 
                   Set=degfilt.se$exptset.seahack,
                   Risk.group=degfilt.se$Risk.group, 
                   deg.risk=degfilt.se$deg.risk)

#define colnames for the random labels in the training set. 
idx <- which(labs$Set=="train")
col.names <- paste("perm",1:5000, sep="_")
class.labels <- c(0,1) # 0 == low, 1 == high/std risk

#create random class labels 
random.labels <- replicate(5000, base::sample(class.labels, size = sum(labs$Set=="train"), replace = TRUE))

#update the labels dataframe with the new randomly created classes. 
labs[,col.names] <- labs$deg.risk
labs[idx,col.names] <- random.labels
```

```{r echo=FALSE}
#Sanity check 
# View(labs[,1:100])
# write.csv(labs, "lasso_permutation_5000_labels.csv", row.names = FALSE)
```

```{r warning=FALSE}
#use sapply to create a list of the results of lasso for each permutation of class labels
permutation.res <- sapply(col.names, function(p){
  print(p)
  
  #a SE object that will be modified with the permutation labels
  seset.per <- degfilt.se 
  
  #update the response variable to be the randomly assigned classes
  seset.per$deg.risk <-  labs[,p]
  
  #run lasso with the randomly assigned group labels
  lasso.perm <- runLasso(seset = seset.per, seed =  as.numeric(str_sub(p, 6))*7)
  return(list(lasso.perm$test.error, lasso.perm$nonzero.coef))
  
}, simplify = FALSE)

# saveRDS(permutation.res, "lasso_permutation_5000_res.RDS")
```

```{r}
l1.tp$test.error #(7%) # 0.06818182

l1.tp$nonzero.coef
```


```{r}
test.errors <- sapply(permutation.res, "[[", 1)
genes.perm <- sapply(permutation.res, "[[", 2) 
```

```{r}
random.goodPerformance <- test.errors[test.errors < 0.1]
# permutation.res[names(random.goodPerformance)]
# sum(names(permutation.res$perm_948[[2]]) %in% names(l1.tp$nonzero.coef))
# which(names(permutation.res$perm_948[[2]]) %in% names(l1.tp$nonzero.coef))

sapply(permutation.res[names(random.goodPerformance)], function(x) sum(grepl("ENSG00000078399", names(x[[2]]))))
sapply(permutation.res[names(random.goodPerformance)], function(x) sum(names(x[[2]]) %in% names(l1.tp$nonzero.coef)))

# View(labs[,c(1:4,4+106),])  
```


Notably, of the 6 random trials in lasso that had a test error of less than 10%, 5/6 included HOXA9 with a positive coefficient
Also, for each of these models, the only one gene in common with the ground truth model is HOXA9.

a 0.12% chance (6/5000) that these genes would randomly assign the correct risk group to the test set.  

```{r}
# jpeg("figures/test_errors_hist_5000x_permutations.tiff", height = 5, width = 5,  units="in", res=200)
hist(test.errors, breaks = seq(0,1, by=0.025), 
     xlab="Test Error", ylab="Number of Occurances", main="Test Errors from Permutation Tests \n with Lasso Regression")
abline(v=l1.tp$test.error, col="red", lwd=2)
# dev.off()
```

```{r}
gene_tally <- data.frame(Gene=rownames(rowData(degfilt.se)))
gene_tally[,col.names] <- NA

head(gene_tally[,1:5])
```

```{r}

```


```{r lasso_allreps}
# lasso model fitting reps and analysis
# lasso reps and model assessment
# Note: reps of lasso were performed on DEGs for TARGET pediatric AML samples
#   Models were optimized using the training subset, then assessed using the validation subset
#   Lasso iterations describe runs after performing lasso on subsets of initial DEGs (>1st rep)

# lasso reps
genes.exclude <- c() # running list of genes (selected features) to exclude

rep1 <- runLasso(seset=degfilt.se)
genes.exclude <- c(genes.exclude, names(rep1$nonzero.coef))

rep2 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep2$nonzero.coef))

rep3 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep3$nonzero.coef))

rep4 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep4$nonzero.coef))

rep5 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep5$nonzero.coef))

rep6 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep6$nonzero.coef))

rep7 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude])
genes.exclude <- c(genes.exclude, names(rep7$nonzero.coef))

rep8 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep8$nonzero.coef))

rep9 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep9$nonzero.coef))

rep10 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep10$nonzero.coef))

rep11 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep11$nonzero.coef))

rep12 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep12$nonzero.coef))

rep13 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep13$nonzero.coef))

rep14 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep14$nonzero.coef))

rep15 <- runLasso(seset=degfilt.se[!rownames(degfilt.se) %in% genes.exclude,])
genes.exclude <- c(genes.exclude, names(rep15$nonzero.coef))

lasso.resultslist <- replist <- list(rep1, rep2, rep3, rep4, rep5, rep6, rep7, rep8,
                rep9, rep10, rep11, rep12, rep13, rep14, rep15)

save(lasso.resultslist, file = paste0(data.dir, sys.sep, "lasso_resultslist.rda"))

#======================================================
# Append rep 1-3 coefficients to standard output table
#======================================================
addLassoCoeff <- function(resultslist){
  repcvar<- rep(0, nrow(degfilt.se))
  names(repcvar) <- rownames(degfilt.se)
  repcoeff <- resultslist$nonzero.coef
  for(i in 1:length(repcoeff)){
    repcvar[names(repcoeff)[i]] <- as.numeric(repcoeff[i])
  }
  return(repcvar)
}

if(identical(rownames(degfilt.se),rownames(standtable))){
  standtable$lasso_coef_rep1 <- addLassoCoeff(rep1)
  standtable$lasso_coef_rep2 <- addLassoCoeff(rep2)
  standtable$lasso_coef_rep3 <- addLassoCoeff(rep3)
}

save(standtable, file = paste0(data.dir, sys.sep, stdtable.name))

# length(intersect(rownames(standtable[!standtable$lasso_coef_rep1==0,]), rownames(standtable[!standtable$lasso_coef_rep2==0,]))) # 0
# length(intersect(rownames(standtable[!standtable$lasso_coef_rep2==0,]), rownames(standtable[!standtable$lasso_coef_rep3==0,]))) # 0

```




```{r lasso_model_performance_plots}
#==========================================
# model performances data frame and graphs
#==========================================

dfp <- as.data.frame(matrix(nrow=15,ncol=5))
colnames(dfp) <- c("rep","tpr","tnr","fdr","for")
dfp$rep <- seq(1,15,1)

postot <- ncol(degfilt.se[,degfilt.se$exptset.seahack=="test" & degfilt.se$deg.risk==1])
falsetot <- ncol(degfilt.se[,degfilt.se$exptset.seahack=="test" & degfilt.se$deg.risk==0])

# True positive rate, TPR = TP/P
tprvar <- c()
for(i in 1:length(replist)){
  tprvar <- c(tprvar, (replist[[i]]$confusionMatrix[2,2]/postot))
}
dfp$tpr <- tprvar

# True negative rate, TNR = TF/F
tnrvar <- c()
for(i in 1:length(replist)){
  tnrvar <- c(tnrvar,(replist[[i]]$confusionMatrix[1,1]/falsetot))
}
dfp$tnr <- tnrvar

# False discovery rate, FDR = 1 - (TP/[TP+FP])
fdrvar <- c()
for(i in 1:length(replist)){
  tp = replist[[i]]$confusionMatrix[2,2]
  fp = replist[[i]]$confusionMatrix[2,1]
  fdrvar <- c(fdrvar, 1-(tp/(tp+fp)))
}
dfp$fdr <- fdrvar

# False omission rate, FOR = 1 - (TN/[TN+FN])
forvar <- c()
for(i in 1:length(replist)){
  tn = replist[[i]]$confusionMatrix[1,1]
  fn = replist[[i]]$confusionMatrix[1,2]
  forvar <- c(forvar, 1-(tn/(tn+fn)))
}
dfp$forvar <- forvar

# graphs

jpeg(paste0(figs.dir, sys.sep, "modelperf_lassoreps15.jpg"), 5,8,units="in",res=400)
par(mfrow=c(2,1),oma=c(2,2,2,1),mar=c(3,3,2,1))

plot(dfp$rep, dfp$tpr, col="blue", ylim = c(0.6,1), 
     main="Lasso Fitted Model Performances")
lines(dfp$rep, dfp$tpr, col="blue")
points(dfp$rep, dfp$tnr, col="red")
lines(dfp$rep, dfp$tnr, col="red")
abline(h=0.8,col="black",lty=2,lwd=1)

legend("bottomleft", c("TPR","TNR"), 
       xpd = TRUE, horiz = TRUE,
       bty = "n", pch = c(1,1), lwd=c(1,1),
       col = c("red","blue"), cex = 1)

plot(dfp$rep, dfp$fdr, col="forestgreen", ylim=c(0,0.3))
lines(dfp$rep,dfp$fdr, col="forestgreen")
points(dfp$rep,dfp$forvar, col="purple")
lines(dfp$rep,dfp$forvar, col="purple")
abline(h=0.2,col="black",lty=2,lwd=1)

legend("topleft", c("FDR","FOR"), 
       xpd = TRUE, horiz = TRUE,
       bty = "n", pch = c(1,1), lwd=c(1,1),
       col = c("forestgreen","purple"), cex = 1)

mtext("Rep",side=1,line=3,cex=1)
mtext("Value",side=2,line=1,cex=1, outer=TRUE)
dev.off()
```
